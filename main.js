(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory((function webpackLoadOptionalExternalModule() { try { return require("sharp"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("canvas"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("electron/common"); } catch(e) {} }()));
	else if(typeof define === 'function' && define.amd)
		define(["sharp", "canvas", "electron/common"], factory);
	else if(typeof exports === 'object')
		exports["TestApp"] = factory((function webpackLoadOptionalExternalModule() { try { return require("sharp"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("canvas"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return require("electron/common"); } catch(e) {} }()));
	else
		root["TestApp"] = factory(root["sharp"], root["canvas"], root["electron/common"]);
})(self, (__WEBPACK_EXTERNAL_MODULE_sharp__, __WEBPACK_EXTERNAL_MODULE_canvas__, __WEBPACK_EXTERNAL_MODULE_electron_common__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./fod.data.png":
/*!**********************!*\
  !*** ./fod.data.png ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./necro10.data.png":
/*!**************************!*\
  !*** ./necro10.data.png ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./necro12.data.png":
/*!**************************!*\
  !*** ./necro12.data.png ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./necro6.data.png":
/*!*************************!*\
  !*** ./necro6.data.png ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./necro8.data.png":
/*!*************************!*\
  !*** ./necro8.data.png ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./soul1.data.png":
/*!************************!*\
  !*** ./soul1.data.png ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./soul2.data.png":
/*!************************!*\
  !*** ./soul2.data.png ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./soul3.data.png":
/*!************************!*\
  !*** ./soul3.data.png ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./soul4.data.png":
/*!************************!*\
  !*** ./soul4.data.png ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./soul5.data.png":
/*!************************!*\
  !*** ./soul5.data.png ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./strike.data.png":
/*!*************************!*\
  !*** ./strike.data.png ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "./volley.data.png":
/*!*************************!*\
  !*** ./volley.data.png ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports=(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js").ImageDetect.imageDataFromBase64)("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")

/***/ }),

/***/ "../node_modules/css-loader/dist/cjs.js!./index.css":
/*!**********************************************************!*\
  !*** ../node_modules/css-loader/dist/cjs.js!./index.css ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ "../node_modules/css-loader/dist/runtime/noSourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "../node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ``, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "../node_modules/css-loader/dist/runtime/api.js":
/*!******************************************************!*\
  !*** ../node_modules/css-loader/dist/runtime/api.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "../node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!***************************************************************!*\
  !*** ../node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (i) {
  return i[1];
};

/***/ }),

/***/ "./index.css":
/*!*******************!*\
  !*** ./index.css ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "../node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "../node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "../node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "../node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./index.css */ "../node_modules/css-loader/dist/cjs.js!./index.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "../node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!*********************************************************************!*\
  !*** ../node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "../node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!***********************************************************************!*\
  !*** ../node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \***********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "../node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!****************************************************************!*\
  !*** ../node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "../node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!**********************************************************************!*\
  !*** ../node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./appconfig.json":
/*!************************!*\
  !*** ./appconfig.json ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "appconfig.json";

/***/ }),

/***/ "./icon.png":
/*!******************!*\
  !*** ./icon.png ***!
  \******************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "icon.png";

/***/ }),

/***/ "./index.html":
/*!********************!*\
  !*** ./index.html ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "index.html";

/***/ }),

/***/ "canvas":
/*!*************************!*\
  !*** external "canvas" ***!
  \*************************/
/***/ ((module) => {

"use strict";
if(typeof __WEBPACK_EXTERNAL_MODULE_canvas__ === 'undefined') { var e = new Error("Cannot find module 'canvas'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE_canvas__;

/***/ }),

/***/ "electron/common":
/*!**********************************!*\
  !*** external "electron/common" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
if(typeof __WEBPACK_EXTERNAL_MODULE_electron_common__ === 'undefined') { var e = new Error("Cannot find module 'electron/common'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE_electron_common__;

/***/ }),

/***/ "sharp":
/*!************************!*\
  !*** external "sharp" ***!
  \************************/
/***/ ((module) => {

"use strict";
if(typeof __WEBPACK_EXTERNAL_MODULE_sharp__ === 'undefined') { var e = new Error("Cannot find module 'sharp'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE_sharp__;

/***/ }),

/***/ "../node_modules/alt1/dist/base/index.js":
/*!***********************************************!*\
  !*** ../node_modules/alt1/dist/base/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory((function webpackLoadOptionalExternalModule() { try { return __webpack_require__(/*! sharp */ "sharp"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return __webpack_require__(/*! canvas */ "canvas"); } catch(e) {} }()), (function webpackLoadOptionalExternalModule() { try { return __webpack_require__(/*! electron/common */ "electron/common"); } catch(e) {} }()));
	else {}
})(globalThis, (__WEBPACK_EXTERNAL_MODULE_sharp__, __WEBPACK_EXTERNAL_MODULE_canvas__, __WEBPACK_EXTERNAL_MODULE_electron_common__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/base/alt1api.ts":
/*!*****************************!*\
  !*** ./src/base/alt1api.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/base/declarations.ts":
/*!**********************************!*\
  !*** ./src/base/declarations.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/base/imagedata-extensions.ts":
/*!******************************************!*\
  !*** ./src/base/imagedata-extensions.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_2062__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageData = void 0;
const a1lib = __importStar(__nested_webpack_require_2062__(/*! ./index */ "./src/base/index.ts"));
const nodeimports = __importStar(__nested_webpack_require_2062__(/*! ./nodepolyfill */ "./src/base/nodepolyfill.ts"));
// //TODO revamp this madness a bit?
// (function () {
// 	var globalvar = (typeof self != "undefined" ? self : (typeof (global as any) != "undefined" ? (global as any) : null)) as any;
// 	//use the node-canvas version when on node
// 	if (typeof globalvar.ImageData == "undefined") {
// 		let nodecnv = requireNodeCanvas();
// 		globalvar.ImageData = nodecnv.ImageData;
// 	}
// 	var fill = typeof globalvar.ImageData == "undefined";
// 	//should never be reach anymore
// 	var constr = function (this: any) {
// 		var i = 0;
// 		var data = (arguments[i] instanceof Uint8ClampedArray ? arguments[i++] : null);
// 		var width = arguments[i++];
// 		var height = arguments[i++];
// 		if (fill) {
// 			if (!data) { data = new Uint8ClampedArray(width * height * 4); }
// 			this.width = width;
// 			this.height = height;
// 			this.data = data;
// 		}
// 		else if (oldconstr) {
// 			return (data ? new oldconstr(data, width, height) : new oldconstr(width, height));
// 		} else {
// 			var canvas = document.createElement('canvas');
// 			canvas.width = width;
// 			canvas.height = height;
// 			var ctx = canvas.getContext("2d")!;
// 			var imageData = ctx.createImageData(width, height);
// 			if (data) { imageData.data.set(data); }
// 			return imageData;
// 		}
// 	}
// 	var oldconstr = globalvar.ImageData;
// 	if (typeof document != "undefined") {
// 		try {
// 			new oldconstr(1, 1);
// 		} catch (e) {
// 			//direct constructor call not allowed in ie
// 			oldconstr = null;
// 		}
// 	}
// 	if (!fill) { constr.prototype = globalvar.ImageData.prototype; }
// 	globalvar.ImageData = constr;
// 	ImageData = constr as any;
// })();
(function () {
    var globalvar = (typeof self != "undefined" ? self : (typeof __nested_webpack_require_2062__.g != "undefined" ? __nested_webpack_require_2062__.g : null));
    var filltype = typeof globalvar.ImageData == "undefined" || typeof globalvar.document == "undefined";
    var fillconstr = filltype;
    if (!filltype) {
        var oldconstr = globalvar.ImageData;
        try {
            let data = new Uint8ClampedArray(4);
            data[0] = 1;
            let a = new globalvar.ImageData(data, 1, 1);
            fillconstr = a.data[0] != 1;
        }
        catch (e) {
            fillconstr = true;
        }
    }
    if (fillconstr) {
        var constr = function ImageDataShim() {
            var i = 0;
            var data = (arguments[i] instanceof Uint8ClampedArray ? arguments[i++] : null);
            var width = arguments[i++];
            var height = arguments[i++];
            if (filltype) {
                if (!data) {
                    data = new Uint8ClampedArray(width * height * 4);
                }
                this.width = width;
                this.height = height;
                this.data = data;
            }
            else if (fillconstr) {
                //WARNING This branch of code does not use the same pixel data backing store
                //(problem with wasm, however all wasm browser have a native constructor (unless asm.js is used))
                var canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                var ctx = canvas.getContext("2d");
                var imageData = ctx.createImageData(width, height);
                if (data) {
                    imageData.data.set(data);
                }
                return imageData;
            }
            // else {
            // 	//oh no...
            // 	//we need this monstrocity in order to call the native constructor with variable number of args
            // 	//when es5 transpile is enable (that strips the spread operator)
            // 	return new (Function.prototype.bind.apply(oldconstr, [null,...arguments]));
            // }
        };
        if (!filltype) {
            constr.prototype = globalvar.ImageData.prototype;
        }
        globalvar.ImageData = constr;
        exports.ImageData = constr;
    }
    else {
        exports.ImageData = globalvar.ImageData;
    }
})();
//Recast into a drawable imagedata class on all platforms, into a normal browser ImageData on browsers or a node-canvas imagedata on nodejs
exports.ImageData.prototype.toDrawableData = function () {
    if (typeof document == "undefined") {
        return nodeimports.imageDataToDrawable(this);
    }
    else {
        return this;
    }
};
exports.ImageData.prototype.putImageData = function (buf, cx, cy) {
    for (var dx = 0; dx < buf.width; dx++) {
        for (var dy = 0; dy < buf.height; dy++) {
            var i1 = (dx + cx) * 4 + (dy + cy) * 4 * this.width;
            var i2 = dx * 4 + dy * 4 * buf.width;
            this.data[i1] = buf.data[i2];
            this.data[i1 + 1] = buf.data[i2 + 1];
            this.data[i1 + 2] = buf.data[i2 + 2];
            this.data[i1 + 3] = buf.data[i2 + 3];
        }
    }
};
exports.ImageData.prototype.pixelOffset = function (x, y) {
    return x * 4 + y * this.width * 4;
};
//creates a hash of a portion of the buffer used to check for changes
exports.ImageData.prototype.getPixelHash = function (rect) {
    if (!rect) {
        rect = new a1lib.Rect(0, 0, this.width, this.height);
    }
    var hash = 0;
    for (var x = rect.x; x < rect.x + rect.width; x++) {
        for (var y = rect.y; y < rect.y + rect.height; y++) {
            var i = x * 4 + y * 4 * this.width;
            hash = (((hash << 5) - hash) + this.data[i]) | 0;
            hash = (((hash << 5) - hash) + this.data[i + 1]) | 0;
            hash = (((hash << 5) - hash) + this.data[i + 2]) | 0;
            hash = (((hash << 5) - hash) + this.data[i + 3]) | 0;
        }
    }
    return hash;
};
exports.ImageData.prototype.clone = function (rect) {
    return this.toImage(rect).getContext("2d").getImageData(0, 0, rect.width, rect.height);
};
exports.ImageData.prototype.show = function (x = 5, y = 5, zoom = 1) {
    if (typeof document == "undefined") {
        console.error("need a document to show an imagedata object");
        return;
    }
    var imgs = document.getElementsByClassName("debugimage");
    while (imgs.length > exports.ImageData.prototype.show.maxImages) {
        imgs[0].remove();
    }
    var el = this.toImage();
    el.classList.add("debugimage");
    el.style.position = "absolute";
    el.style.zIndex = "1000";
    el.style.left = x / zoom + "px";
    el.style.top = y / zoom + "px";
    el.style.background = "purple";
    el.style.cursor = "pointer";
    el.style.imageRendering = "pixelated";
    el.style.outline = "1px solid #0f0";
    el.style.width = (this.width == 1 ? 100 : this.width) * zoom + "px";
    el.style.height = (this.height == 1 ? 100 : this.height) * zoom + "px";
    el.onclick = function () { el.remove(); };
    document.body.appendChild(el);
    return el;
};
exports.ImageData.prototype.show.maxImages = 10;
exports.ImageData.prototype.toImage = function (rect) {
    if (!rect) {
        rect = new a1lib.Rect(0, 0, this.width, this.height);
    }
    if (typeof document != "undefined") {
        var el = document.createElement("canvas");
        el.width = rect.width;
        el.height = rect.height;
    }
    else {
        el = nodeimports.createCanvas(rect.width, rect.height);
    }
    var ctx = el.getContext("2d");
    ctx.putImageData(this.toDrawableData(), -rect.x, -rect.y);
    return el;
};
exports.ImageData.prototype.getPixel = function (x, y) {
    var i = x * 4 + y * 4 * this.width;
    return [this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]];
};
exports.ImageData.prototype.getPixelValueSum = function (x, y) {
    var i = x * 4 + y * 4 * this.width;
    return this.data[i] + this.data[i + 1] + this.data[i + 2];
};
exports.ImageData.prototype.getPixelInt = function (x, y) {
    var i = x * 4 + y * 4 * this.width;
    return (this.data[i + 3] << 24) + (this.data[i + 0] << 16) + (this.data[i + 1] << 8) + (this.data[i + 2] << 0);
};
exports.ImageData.prototype.getColorDifference = function (x, y, r, g, b, a = 255) {
    var i = x * 4 + y * 4 * this.width;
    return Math.abs(this.data[i] - r) + Math.abs(this.data[i + 1] - g) + Math.abs(this.data[i + 2] - b) * a / 255;
};
exports.ImageData.prototype.setPixel = function (x, y, ...color) {
    var r, g, b, a;
    var [r, g, b, a] = (Array.isArray(color[0]) ? color[0] : color);
    var i = x * 4 + y * 4 * this.width;
    this.data[i] = r;
    this.data[i + 1] = g;
    this.data[i + 2] = b;
    this.data[i + 3] = a == undefined ? 255 : a;
};
exports.ImageData.prototype.setPixelInt = function (x, y, color) {
    var i = x * 4 + y * 4 * this.width;
    this.data[i] = (color >> 24) & 0xff;
    this.data[i + 1] = (color >> 16) & 0xff;
    this.data[i + 2] = (color >> 8) & 0xff;
    this.data[i + 3] = (color >> 0) & 0xff;
};
exports.ImageData.prototype.toFileBytes = function (format, quality) {
    if (typeof HTMLCanvasElement != "undefined") {
        return new Promise(d => this.toImage().toBlob(b => {
            var r = new FileReader();
            r.readAsArrayBuffer(b);
            r.onload = () => d(new Uint8Array(r.result));
        }, format, quality));
    }
    else {
        return nodeimports.imageDataToFileBytes(this, format, quality);
    }
};
exports.ImageData.prototype.toPngBase64 = function () {
    if (typeof HTMLCanvasElement != "undefined") {
        var str = this.toImage().toDataURL("image/png");
        return str.slice(str.indexOf(",") + 1);
    }
    else {
        throw new Error("synchronous image conversion not supported in nodejs, try using ImageData.prototype.toFileBytes");
    }
};
exports.ImageData.prototype.pixelCompare = function (buf, x = 0, y = 0, max) {
    return a1lib.ImageDetect.simpleCompare(this, buf, x, y, max);
};
exports.ImageData.prototype.copyTo = function (target, sourcex, sourcey, width, height, targetx, targety) {
    //convince v8 that these are 31bit uints
    const targetwidth = target.width | 0;
    const thiswidth = this.width | 0;
    const copywidth = width | 0;
    const fastwidth = Math.floor(width / 4) * 4;
    const thisdata = new Int32Array(this.data.buffer, this.data.byteOffset, this.data.byteLength / 4);
    const targetdata = new Int32Array(target.data.buffer, target.data.byteOffset, target.data.byteLength / 4);
    for (let cy = 0; cy < height; cy++) {
        let cx = 0;
        let it = (cx + targetx) + (cy + targety) * targetwidth;
        let is = (cx + sourcex) + (cy + sourcey) * thiswidth;
        //copy 4 pixels per iter (xmm)
        for (; cx < fastwidth; cx += 4) {
            targetdata[it] = thisdata[is];
            targetdata[it + 1] = thisdata[is + 1];
            targetdata[it + 2] = thisdata[is + 2];
            targetdata[it + 3] = thisdata[is + 3];
            it += 4;
            is += 4;
        }
        //copy remainder per pixel
        for (; cx < copywidth; cx++) {
            targetdata[it] = thisdata[is];
            it += 1;
            is += 1;
        }
    }
};
if (typeof HTMLImageElement != "undefined") {
    HTMLImageElement.prototype.toBuffer = function (x = 0, y = 0, w = this.width, h = this.height) {
        var cnv = document.createElement("canvas");
        cnv.width = w;
        cnv.height = h;
        var ctx = cnv.getContext("2d");
        ctx.drawImage(this, -x, -y);
        return ctx.getImageData(0, 0, w, h);
    };
    HTMLImageElement.prototype.toCanvas = function (x = 0, y = 0, w = this.width, h = this.height) {
        var cnv = document.createElement("canvas");
        cnv.width = w;
        cnv.height = h;
        var ctx = cnv.getContext("2d");
        ctx.drawImage(this, -x, -y);
        return cnv;
    };
}


/***/ }),

/***/ "./src/base/imagedetect.ts":
/*!*********************************!*\
  !*** ./src/base/imagedetect.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_15248__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageDataSet = exports.webpackImages = exports.asyncMap = exports.coldif = exports.simpleCompareRMSE = exports.simpleCompare = exports.findSubbuffer = exports.findSubimage = exports.clearPngColorspace = exports.isPngBuffer = exports.imageDataFromFileBuffer = exports.imageDataFromBase64 = exports.imageDataFromUrl = void 0;
const imgref_1 = __nested_webpack_require_15248__(/*! ./imgref */ "./src/base/imgref.ts");
const wapper = __importStar(__nested_webpack_require_15248__(/*! ./wrapper */ "./src/base/wrapper.ts"));
const nodeimports = __importStar(__nested_webpack_require_15248__(/*! ./nodepolyfill */ "./src/base/nodepolyfill.ts"));
const _1 = __nested_webpack_require_15248__(/*! . */ "./src/base/index.ts");
/**
* Downloads an image and returns the ImageData
* Make sure the png image does not have a sRGB chunk or the resulting pixels will differ for different users!!!
* @param url http(s) or data url to the image
*/
async function imageDataFromUrl(url) {
    if (typeof Image != "undefined") {
        var img = new Image();
        img.crossOrigin = "crossorigin";
        return await new Promise((done, fail) => {
            img.onload = function () { done(img.toBuffer()); };
            img.onerror = fail;
            img.src = url;
        });
    }
    else {
        var hdr = "data:image/png;base64,";
        if (url.startsWith(hdr)) {
            return imageDataFromBase64(url.slice(hdr.length));
        }
        throw new Error("loading remote images in nodejs has been disabled, load the raw bytes and use imageDataFromNodeBuffer instead");
    }
}
exports.imageDataFromUrl = imageDataFromUrl;
/**
* Loads an ImageData object from a base64 encoded png image
* Make sure the png image does not have a sRGB chunk or the resulting pixels will differ for different users!!!
* @param data a base64 encoded png image
*/
async function imageDataFromBase64(data) {
    if (typeof Image != "undefined") {
        return imageDataFromUrl("data:image/png;base64," + data);
    }
    else {
        return nodeimports.imageDataFromBase64(data);
    }
}
exports.imageDataFromBase64 = imageDataFromBase64;
/**
 * Loads an ImageData object directly from a png encoded file buffer
 * This method ensures that png color space headers are taken care off
 * @param data The bytes of a png file
 */
async function imageDataFromFileBuffer(data) {
    clearPngColorspace(data);
    if (typeof Image != "undefined") {
        let blob = new Blob([data], { type: "image/png" });
        let url = URL.createObjectURL(blob);
        let r = await imageDataFromUrl(url);
        URL.revokeObjectURL(url);
        return r;
    }
    else {
        return nodeimports.imageDataFromBuffer(data);
    }
}
exports.imageDataFromFileBuffer = imageDataFromFileBuffer;
/**
* Checks if a given byte array is a png file (by checking for ?PNG as first 4 bytes)
* @param bytes Raw bytes of the png file
*/
function isPngBuffer(bytes) {
    return bytes[0] == 137 && bytes[1] == 80 && bytes[2] == 78 && bytes[3] == 71;
}
exports.isPngBuffer = isPngBuffer;
/**
* Resets the colorspace data in the png file.
* This makes sure the browser renders the exact colors in the file instead of filtering it in order to obtain the best real life representation of
* what it looked like on the authors screen. (this feature is often broken and not supported)
* For example a round trip printscreen -> open in browser results in different colors than the original
* @param data Raw bytes of the png file
*/
function clearPngColorspace(data) {
    if (!isPngBuffer(data)) {
        throw new Error("non-png image received");
    }
    var i = 8;
    while (i < data.length) {
        var length = data[i++] * 0x1000000 + data[i++] * 0x10000 + data[i++] * 0x100 + data[i++];
        var ancillary = !!((data[i] >> 5) & 1);
        var chunkname = String.fromCharCode(data[i], data[i + 1], data[i + 2], data[i + 3]);
        var chunkid = chunkname.toLowerCase();
        if (chunkid != "trns" && ancillary) {
            data[i + 0] = "n".charCodeAt(0);
            data[i + 1] = "o".charCodeAt(0);
            data[i + 2] = "P".charCodeAt(0);
            data[i + 3] = "E".charCodeAt(0);
            //calculate new chunk checksum
            //http://www.libpng.org/pub/png/spec/1.2/PNG-CRCAppendix.html
            var end = i + 4 + length;
            var crc = 0xffffffff;
            //should be fast enough like this
            var bitcrc = function (bit) {
                for (var k = 0; k < 8; k++) {
                    if (bit & 1) {
                        bit = 0xedb88320 ^ (bit >>> 1);
                    }
                    else {
                        bit = bit >>> 1;
                    }
                }
                return bit;
            };
            for (var a = i; a < end; a++) {
                if (a >= i + 4) {
                    data[a] = 0;
                }
                var bit = data[a];
                crc = bitcrc((crc ^ bit) & 0xff) ^ (crc >>> 8);
            }
            crc = crc ^ 0xffffffff;
            //new chunk checksum
            data[i + 4 + length + 0] = (crc >> 24) & 0xff;
            data[i + 4 + length + 1] = (crc >> 16) & 0xff;
            data[i + 4 + length + 2] = (crc >> 8) & 0xff;
            data[i + 4 + length + 3] = (crc >> 0) & 0xff;
        }
        if (chunkname == "IEND") {
            break;
        }
        i += 4; //type
        i += length; //data
        i += 4; //crc
    }
}
exports.clearPngColorspace = clearPngColorspace;
/**
* finds the given needle ImageBuffer in the given haystack ImgRef this function uses the best optimized available
* code depending on the type of the haystack. It will use fast c# searching if the haystack is an ImgRefBind, js searching
* is used otherwise.
* the checklist argument is no longer used and should ignored or null/undefined
* The optional sx,sy,sw,sh arguments indicate a bounding rectangle in which to search the needle. The rectangle should be bigger than the needle
* @returns An array of points where the needle is found. The array is empty if none are found
*/
function findSubimage(haystackImgref, needleBuffer, sx = 0, sy = 0, sw = haystackImgref.width, sh = haystackImgref.height) {
    if (!haystackImgref) {
        throw new TypeError();
    }
    if (!needleBuffer) {
        throw new TypeError();
    }
    var max = 30;
    //check if we can do this in alt1
    if (haystackImgref instanceof imgref_1.ImgRefBind && wapper.hasAlt1 && alt1.bindFindSubImg) {
        var needlestr = wapper.encodeImageString(needleBuffer);
        var r = alt1.bindFindSubImg(haystackImgref.handle, needlestr, needleBuffer.width, sx, sy, sw, sh);
        if (!r) {
            throw new wapper.Alt1Error();
        }
        return JSON.parse(r);
    }
    return findSubbuffer(haystackImgref.read(), needleBuffer, sx, sy, sw, sh);
}
exports.findSubimage = findSubimage;
/**
* Uses js to find the given needle ImageBuffer in the given haystack ImageBuffer. It is better to use the alt1.bind- functions in
* combination with a1nxt.findsubimg.
* the optional sx,sy,sw,sh arguments indicate a bounding rectangle in which to search.
* @returns An array of points where the needle is found. The array is empty if none are found
*/
function findSubbuffer(haystack, needle, sx = 0, sy = 0, sw = haystack.width, sh = haystack.height) {
    var r = [];
    var maxdif = 30;
    var maxresults = 50;
    var needlestride = needle.width * 4;
    var heystackstride = haystack.width * 4;
    //built list of non trans pixel to check
    var checkList = [];
    for (var y = 0; y < needle.height; y++) {
        for (var x = 0; x < needle.width; x++) {
            var i = x * 4 + y * needlestride;
            if (needle.data[i + 3] == 255) {
                checkList.push({ x: x, y: y });
            }
            if (checkList.length == 10) {
                break;
            }
        }
        if (checkList.length == 10) {
            break;
        }
    }
    var cw = (sx + sw) - needle.width;
    var ch = (sy + sh) - needle.height;
    var checklength = checkList.length;
    for (var y = sy; y <= ch; y++) {
        outer: for (var x = sx; x <= cw; x++) {
            for (var a = 0; a < checklength; a++) {
                var i1 = (x + checkList[a].x) * 4 + (y + checkList[a].y) * heystackstride;
                var i2 = checkList[a].x * 4 + checkList[a].y * needlestride;
                var d = 0;
                d = d + Math.abs(haystack.data[i1 + 0] - needle.data[i2 + 0]) | 0;
                d = d + Math.abs(haystack.data[i1 + 1] - needle.data[i2 + 1]) | 0;
                d = d + Math.abs(haystack.data[i1 + 2] - needle.data[i2 + 2]) | 0;
                d *= 255 / needle.data[i2 + 3];
                if (d > maxdif) {
                    continue outer;
                }
            }
            if (simpleCompare(haystack, needle, x, y, maxdif) != Infinity) {
                r.push({ x, y });
                if (r.length > maxresults) {
                    return r;
                }
            }
        }
    }
    return r;
}
exports.findSubbuffer = findSubbuffer;
/**
* Compares two images and returns the average color difference per pixel between them
* @param max The max color difference at any point in the image before short circuiting the function and returning Infinity. set to -1 to always continue.
* @returns The average color difference per pixel or Infinity if the difference is more than max at any point in the image
*/
function simpleCompare(bigbuf, checkbuf, x, y, max = 30) {
    if (x < 0 || y < 0) {
        throw new RangeError();
    }
    if (x + checkbuf.width > bigbuf.width || y + checkbuf.height > bigbuf.height) {
        throw new RangeError();
    }
    if (max == -1) {
        max = 255 * 4;
    }
    var dif = 0;
    for (var step = 8; step >= 1; step /= 2) {
        for (var cx = 0; cx < checkbuf.width; cx += step) {
            for (var cy = 0; cy < checkbuf.height; cy += step) {
                var i1 = (x + cx) * 4 + (y + cy) * bigbuf.width * 4;
                var i2 = cx * 4 + cy * checkbuf.width * 4;
                var d = 0;
                d = d + Math.abs(bigbuf.data[i1 + 0] - checkbuf.data[i2 + 0]) | 0;
                d = d + Math.abs(bigbuf.data[i1 + 1] - checkbuf.data[i2 + 1]) | 0;
                d = d + Math.abs(bigbuf.data[i1 + 2] - checkbuf.data[i2 + 2]) | 0;
                d *= checkbuf.data[i2 + 3] / 255;
                if (step == 1) {
                    dif += d;
                }
                if (d > max) {
                    return Infinity;
                }
            }
        }
    }
    return dif / checkbuf.width / checkbuf.height;
}
exports.simpleCompare = simpleCompare;
/**
* Calculates the root mean square error between the two buffers at the given coordinate, this method can be used in situations with significant blur or
* transparency, it does not bail early on non-matching images like simpleCompare does so it can be expected to be much slower when called often.
* @returns The root mean square error beteen the images, high single pixel errors are penalized more than consisten low errors. return of 0 means perfect match.
*/
function simpleCompareRMSE(bigbuf, checkbuf, x, y) {
    if (x < 0 || y < 0) {
        throw new RangeError();
    }
    if (x + checkbuf.width > bigbuf.width || y + checkbuf.height > bigbuf.height) {
        throw new RangeError();
    }
    var dif = 0;
    var numpix = 0;
    for (var cx = 0; cx < checkbuf.width; cx++) {
        for (var cy = 0; cy < checkbuf.height; cy++) {
            var i1 = (x + cx) * 4 + (y + cy) * bigbuf.width * 4;
            var i2 = cx * 4 + cy * checkbuf.width * 4;
            var d = 0;
            d = d + Math.abs(bigbuf.data[i1 + 0] - checkbuf.data[i2 + 0]) | 0;
            d = d + Math.abs(bigbuf.data[i1 + 1] - checkbuf.data[i2 + 1]) | 0;
            d = d + Math.abs(bigbuf.data[i1 + 2] - checkbuf.data[i2 + 2]) | 0;
            var weight = checkbuf.data[i2 + 3] / 255;
            numpix += weight;
            dif += d * d * weight;
        }
    }
    return Math.sqrt(dif / numpix);
}
exports.simpleCompareRMSE = simpleCompareRMSE;
/**
* Returns the difference between two colors (scaled to the alpha of the second color)
*/
function coldif(r1, g1, b1, r2, g2, b2, a2) {
    return (Math.abs(r1 - r2) + Math.abs(g1 - g2) + Math.abs(b1 - b2)) * a2 / 255; //only applies alpha for 2nd buffer!
}
exports.coldif = coldif;
/**
 * Turns map of promises into a map that contains the resolved values after loading.
 * @param input
 */
function asyncMap(input) {
    var raw = {};
    var promises = [];
    for (var a in input) {
        if (input.hasOwnProperty(a)) {
            raw[a] = null;
            promises.push(input[a].then(function (a, i) { raw[a] = i; r[a] = i; }.bind(null, a)));
        }
    }
    var r = {};
    var promise = Promise.all(promises).then(() => { r.loaded = true; return r; });
    Object.defineProperty(r, "loaded", { enumerable: false, value: false, writable: true });
    Object.defineProperty(r, "promise", { enumerable: false, value: promise });
    Object.defineProperty(r, "raw", { enumerable: false, value: raw });
    return Object.assign(r, raw);
}
exports.asyncMap = asyncMap;
/**
* Same as asyncMap, but casts the properties to ImageData in typescript
*/
function webpackImages(input) {
    return asyncMap(input);
}
exports.webpackImages = webpackImages;
class ImageDataSet {
    constructor() {
        this.buffers = [];
    }
    matchBest(img, x, y, max) {
        let best = null;
        let bestscore = max;
        for (let a = 0; a < this.buffers.length; a++) {
            let score = img.pixelCompare(this.buffers[a], x, y, bestscore);
            if (isFinite(score) && (bestscore == undefined || score < bestscore)) {
                bestscore = score;
                best = a;
            }
        }
        if (best == null) {
            return null;
        }
        return { index: best, score: bestscore };
    }
    static fromFilmStrip(baseimg, width) {
        if ((baseimg.width % width) != 0) {
            throw new Error("slice size does not fit in base img");
        }
        let r = new ImageDataSet();
        for (let x = 0; x < baseimg.width; x += width) {
            r.buffers.push(baseimg.clone(new _1.Rect(x, 0, width, baseimg.height)));
        }
        return r;
    }
    static fromFilmStripUneven(baseimg, widths) {
        let r = new ImageDataSet();
        let x = 0;
        for (let w of widths) {
            r.buffers.push(baseimg.clone(new _1.Rect(x, 0, w, baseimg.height)));
            x += w;
            if (x > baseimg.width) {
                throw new Error("sampling filmstrip outside bounds");
            }
        }
        if (x != baseimg.width) {
            throw new Error("unconsumed pixels left in film strip imagedata");
        }
        return r;
    }
    static fromAtlas(baseimg, slices) {
        let r = new ImageDataSet();
        for (let slice of slices) {
            r.buffers.push(baseimg.clone(slice));
        }
        return r;
    }
}
exports.ImageDataSet = ImageDataSet;


/***/ }),

/***/ "./src/base/imgref.ts":
/*!****************************!*\
  !*** ./src/base/imgref.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_31629__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImgRefData = exports.ImgRefBind = exports.ImgRefCtx = exports.ImgRef = void 0;
const index_1 = __nested_webpack_require_31629__(/*! ./index */ "./src/base/index.ts");
/**
 * Represents an image that might be in different types of memory
 * This is mostly used to represent images still in Alt1 memory that have
 * not been transfered to js yet. Various a1lib api's use this type and
 * choose the most efficient approach based on the memory type
 */
class ImgRef {
    constructor(x, y, w, h) {
        this.t = "none";
        this.x = x;
        this.y = y;
        this.width = w;
        this.height = h;
    }
    read(x = 0, y = 0, w = this.width, h = this.height) {
        throw new Error("This imgref (" + this.t + ") does not support toData");
    }
    findSubimage(needle, sx = 0, sy = 0, w = this.width, h = this.height) {
        return index_1.ImageDetect.findSubimage(this, needle, sx, sy, w, h);
    }
    toData(x = this.x, y = this.y, w = this.width, h = this.height) {
        return this.read(x - this.x, y - this.y, w, h);
    }
    ;
    containsArea(rect) {
        return this.x <= rect.x && this.y <= rect.y && this.x + this.width >= rect.x + rect.width && this.y + this.height >= rect.y + rect.height;
    }
}
exports.ImgRef = ImgRef;
/**
 * Represents an image in js render memory (canvas/image tag)
 */
class ImgRefCtx extends ImgRef {
    constructor(img, x = 0, y = 0) {
        if (img instanceof CanvasRenderingContext2D) {
            super(x, y, img.canvas.width, img.canvas.height);
            this.ctx = img;
        }
        else {
            super(x, y, img.width, img.height);
            var cnv = (img instanceof HTMLCanvasElement ? img : img.toCanvas());
            this.ctx = cnv.getContext("2d");
        }
        this.t = "ctx";
    }
    read(x = 0, y = 0, w = this.width, h = this.height) {
        return this.ctx.getImageData(x, y, w, h);
    }
}
exports.ImgRefCtx = ImgRefCtx;
/**
 * Represents in image in Alt1 memory, This type of image can be searched for subimages
 * very efficiently and transfering the full image to js can be avoided this way
 */
class ImgRefBind extends ImgRef {
    constructor(handle, x = 0, y = 0, w = 0, h = 0) {
        super(x, y, w, h);
        this.handle = handle;
        this.t = "bind";
    }
    read(x = 0, y = 0, w = this.width, h = this.height) {
        return (0, index_1.transferImageData)(this.handle, x, y, w, h);
    }
}
exports.ImgRefBind = ImgRefBind;
/**
 * Represents an image in js memory
 */
class ImgRefData extends ImgRef {
    constructor(buf, x = 0, y = 0) {
        super(x, y, buf.width, buf.height);
        this.buf = buf;
        this.t = "data";
    }
    read(x = 0, y = 0, w = this.width, h = this.height) {
        if (x == 0 && y == 0 && w == this.width && h == this.height) {
            return this.buf;
        }
        var r = new ImageData(w, h);
        for (var b = y; b < y + h; b++) {
            for (var a = x; a < x + w; a++) {
                var i1 = (a - x) * 4 + (b - y) * w * 4;
                var i2 = a * 4 + b * 4 * this.buf.width;
                r.data[i1] = this.buf.data[i2];
                r.data[i1 + 1] = this.buf.data[i2 + 1];
                r.data[i1 + 2] = this.buf.data[i2 + 2];
                r.data[i1 + 3] = this.buf.data[i2 + 3];
            }
        }
        return r;
    }
}
exports.ImgRefData = ImgRefData;


/***/ }),

/***/ "./src/base/index.ts":
/*!***************************!*\
  !*** ./src/base/index.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_35283__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImageDataSet = exports.findSubbuffer = exports.simpleCompare = exports.findSubimage = exports.webpackImages = exports.NodePolyfill = exports.ImageData = exports.Rect = exports.PasteInput = exports.ImageDetect = void 0;
__nested_webpack_require_35283__(/*! ./declarations */ "./src/base/declarations.ts");
exports.ImageDetect = __importStar(__nested_webpack_require_35283__(/*! ./imagedetect */ "./src/base/imagedetect.ts"));
exports.PasteInput = __importStar(__nested_webpack_require_35283__(/*! ./pasteinput */ "./src/base/pasteinput.ts"));
var rect_1 = __nested_webpack_require_35283__(/*! ./rect */ "./src/base/rect.ts");
Object.defineProperty(exports, "Rect", ({ enumerable: true, get: function () { return __importDefault(rect_1).default; } }));
var imagedata_extensions_1 = __nested_webpack_require_35283__(/*! ./imagedata-extensions */ "./src/base/imagedata-extensions.ts");
Object.defineProperty(exports, "ImageData", ({ enumerable: true, get: function () { return imagedata_extensions_1.ImageData; } }));
exports.NodePolyfill = __importStar(__nested_webpack_require_35283__(/*! ./nodepolyfill */ "./src/base/nodepolyfill.ts"));
__exportStar(__nested_webpack_require_35283__(/*! ./imgref */ "./src/base/imgref.ts"), exports);
__exportStar(__nested_webpack_require_35283__(/*! ./wrapper */ "./src/base/wrapper.ts"), exports);
var imagedetect_1 = __nested_webpack_require_35283__(/*! ./imagedetect */ "./src/base/imagedetect.ts");
Object.defineProperty(exports, "webpackImages", ({ enumerable: true, get: function () { return imagedetect_1.webpackImages; } }));
Object.defineProperty(exports, "findSubimage", ({ enumerable: true, get: function () { return imagedetect_1.findSubimage; } }));
Object.defineProperty(exports, "simpleCompare", ({ enumerable: true, get: function () { return imagedetect_1.simpleCompare; } }));
Object.defineProperty(exports, "findSubbuffer", ({ enumerable: true, get: function () { return imagedetect_1.findSubbuffer; } }));
Object.defineProperty(exports, "ImageDataSet", ({ enumerable: true, get: function () { return imagedetect_1.ImageDataSet; } }));


/***/ }),

/***/ "./src/base/nodepolyfill.ts":
/*!**********************************!*\
  !*** ./src/base/nodepolyfill.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_38931__) => {


//nodejs and electron polyfills for web api's
//commented out type info as that breaks webpack with optional dependencies
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.imageDataFromBuffer = exports.imageDataFromBase64 = exports.imageDataToFileBytes = exports.createCanvas = exports.imageDataToDrawable = exports.requireElectronCommon = exports.requireNodeCanvas = exports.requireSharp = exports.polyfillRequire = void 0;
const index_1 = __nested_webpack_require_38931__(/*! ./index */ "./src/base/index.ts");
const imagedetect_1 = __nested_webpack_require_38931__(/*! ./imagedetect */ "./src/base/imagedetect.ts");
var requirefunction = null;
/**
 * Call this function to let the libs require extra dependencies on nodejs in order
 * to polyfill some browser api's (mostly image compression/decompression)
 * `NodePolifill.polyfillRequire(require);` should solve most cases
 */
function polyfillRequire(requirefn) {
    requirefunction = requirefn;
}
exports.polyfillRequire = polyfillRequire;
function requireSharp() {
    try {
        if (requirefunction) {
            return requirefunction("sharp");
        }
        else {
            return __nested_webpack_require_38931__(/* webpackIgnore: true */ /*! sharp */ "sharp"); // as typeof import("sharp");
        }
    }
    catch (e) { }
    return null;
}
exports.requireSharp = requireSharp;
function requireNodeCanvas() {
    //attempt to require sharp first, after loading canvas the module sharp fails to load
    requireSharp();
    try {
        if (requirefunction) {
            return requirefunction("canvas");
        }
        else {
            return __nested_webpack_require_38931__(/* webpackIgnore: true */ /*! canvas */ "canvas"); // as typeof import("sharp");
        }
    }
    catch (e) { }
    return null;
}
exports.requireNodeCanvas = requireNodeCanvas;
function requireElectronCommon() {
    try {
        if (requirefunction) {
            return requirefunction("electron/common");
        }
        else {
            return __nested_webpack_require_38931__(/* webpackIgnore: true */ /*! electron/common */ "electron/common");
        }
    }
    catch (e) { }
    return null;
}
exports.requireElectronCommon = requireElectronCommon;
function imageDataToDrawable(buf) {
    let nodecnv = requireNodeCanvas();
    if (!nodecnv) {
        throw new Error("couldn't find built-in canvas or the module 'canvas'");
    }
    return new nodecnv.ImageData(buf.data, buf.width, buf.height);
}
exports.imageDataToDrawable = imageDataToDrawable;
function createCanvas(w, h) {
    let nodecnv = requireNodeCanvas();
    if (!nodecnv) {
        throw new Error("couldn't find built-in canvas or the module 'canvas'");
    }
    return nodecnv.createCanvas(w, h);
}
exports.createCanvas = createCanvas;
function flipBGRAtoRGBA(data) {
    for (let i = 0; i < data.length; i += 4) {
        let tmp = data[i + 2];
        data[i + 2] = data[i + 0];
        data[i + 0] = tmp;
    }
}
async function imageDataToFileBytes(buf, format, quality) {
    //use the electron API if we're in electron
    var electronCommon;
    var sharp;
    if (electronCommon = requireElectronCommon()) {
        let nativeImage = electronCommon.nativeImage;
        //need to copy the buffer in order to flip it without destroying the original
        let bufcpy = Buffer.from(buf.data.slice(buf.data.byteOffset, buf.data.byteLength));
        flipBGRAtoRGBA(bufcpy);
        let nativeimg = nativeImage.createFromBitmap(bufcpy, { width: buf.width, height: buf.height });
        return nativeimg.toPNG();
    }
    else if (sharp = requireSharp()) {
        let img = sharp(Buffer.from(buf.data.buffer), { raw: { width: buf.width, height: buf.height, channels: 4 } });
        if (format == "image/png") {
            img.png();
        }
        else if (format == "image/webp") {
            var opts = { quality: 80 };
            if (typeof quality == "number") {
                opts.quality = quality * 100;
            }
            img.webp(opts);
        }
        else {
            throw new Error("unknown image format: " + format);
        }
        return await img.toBuffer({ resolveWithObject: false }).buffer;
    }
    throw new Error("coulnd't find build-in image compression methods or the module 'electron/common' or 'sharp'");
}
exports.imageDataToFileBytes = imageDataToFileBytes;
function imageDataFromBase64(base64) {
    return imageDataFromBuffer(Buffer.from(base64, "base64"));
}
exports.imageDataFromBase64 = imageDataFromBase64;
async function imageDataFromBuffer(buffer) {
    (0, imagedetect_1.clearPngColorspace)(buffer);
    //use the electron API if we're in electron
    var electronCommon;
    var nodecnv;
    if (electronCommon = requireElectronCommon()) {
        let nativeImage = electronCommon.nativeImage;
        let img = nativeImage.createFromBuffer(buffer);
        let pixels = img.toBitmap();
        let size = img.getSize();
        let pixbuf = new Uint8ClampedArray(pixels.buffer, pixels.byteOffset, pixels.byteLength);
        flipBGRAtoRGBA(pixbuf);
        return new index_1.ImageData(pixbuf, size.width, size.height);
    }
    else if (nodecnv = requireNodeCanvas()) {
        return new Promise((done, err) => {
            let img = new nodecnv.Image();
            img.onerror = err;
            img.onload = () => {
                var cnv = nodecnv.createCanvas(img.naturalWidth, img.naturalHeight);
                var ctx = cnv.getContext("2d");
                ctx.drawImage(img, 0, 0);
                var data = ctx.getImageData(0, 0, img.naturalWidth, img.naturalHeight);
                //use our own class
                done(new index_1.ImageData(data.data, data.width, data.height));
            };
            img.src = Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        });
    }
    throw new Error("couldn't find built-in canvas, module 'electron/common' or the module 'canvas'");
}
exports.imageDataFromBuffer = imageDataFromBuffer;


/***/ }),

/***/ "./src/base/pasteinput.ts":
/*!********************************!*\
  !*** ./src/base/pasteinput.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_45123__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fileDialog = exports.start = exports.startDragNDrop = exports.triggerPaste = exports.unlisten = exports.listen = exports.lastref = void 0;
const index_1 = __nested_webpack_require_45123__(/*! ./index */ "./src/base/index.ts");
const ImageDetect = __importStar(__nested_webpack_require_45123__(/*! ./imagedetect */ "./src/base/imagedetect.ts"));
var listeners = [];
var started = false;
var dndStarted = false;
var pasting = false;
exports.lastref = null;
function listen(func, errorfunc, dragndrop) {
    listeners.push({ cb: func, error: errorfunc });
    if (!started) {
        start();
    }
    if (dragndrop && !dndStarted) {
        startDragNDrop();
    }
}
exports.listen = listen;
function unlisten(func) {
    let i = listeners.findIndex(c => c.cb == func);
    if (i != -1) {
        listeners.splice(i, 1);
    }
}
exports.unlisten = unlisten;
/**
 * currently used in multiple document situations (iframe), might be removed in the future
 */
function triggerPaste(img) {
    exports.lastref = img;
    for (var a in listeners) {
        listeners[a].cb(exports.lastref);
    }
}
exports.triggerPaste = triggerPaste;
function pasted(img) {
    pasting = false;
    let cnv = img instanceof HTMLCanvasElement ? img : img.toCanvas();
    triggerPaste(new index_1.ImgRefCtx(cnv));
}
function error(error, mes) {
    var _a, _b;
    pasting = false;
    for (var a in listeners) {
        (_b = (_a = listeners[a]).error) === null || _b === void 0 ? void 0 : _b.call(_a, mes, error);
    }
}
function startDragNDrop() {
    var getitem = function (items) {
        var foundimage = "";
        for (var a = 0; a < items.length; a++) {
            var item = items[a];
            var m = item.type.match(/^image\/(\w+)$/);
            if (m) {
                if (m[1] == "png") {
                    return item;
                }
                else {
                    foundimage = m[1];
                }
            }
        }
        if (foundimage) {
            error("notpng", "The image you uploaded is not a .png image. Other image type have compression noise and can't be used for image detection.");
        }
        return null;
    };
    window.addEventListener("dragover", function (e) {
        e.preventDefault();
    });
    window.addEventListener("drop", function (e) {
        if (!e.dataTransfer) {
            return;
        }
        var item = getitem(e.dataTransfer.items);
        e.preventDefault();
        if (!item) {
            return;
        }
        fromFile(item.getAsFile());
    });
}
exports.startDragNDrop = startDragNDrop;
function start() {
    if (started) {
        return;
    }
    started = true;
    //determine if we have a clipboard api
    //try{a=new Event("clipboard"); a="clipboardData" in a;}
    //catch(e){a=false;}
    var ischrome = !!navigator.userAgent.match(/Chrome/) && !navigator.userAgent.match(/Edge/);
    //old method breaks after chrome 41, revert to good old user agent sniffing
    //nvm, internet explorer (edge) decided that it wants to be chrome, however fails at delivering
    //turns out this one is interesting, edge is a hybrid between the paste api's
    var apipasted = function (e) {
        if (!e.clipboardData) {
            return;
        }
        for (var a = 0; a < e.clipboardData.items.length; a++) { //loop all data types
            if (e.clipboardData.items[a].type.indexOf("image") != -1) {
                var file = e.clipboardData.items[a].getAsFile();
                if (file) {
                    var img = new Image();
                    img.src = (window.URL || window.webkitURL).createObjectURL(file);
                    if (img.width > 0) {
                        pasted(img);
                    }
                    else {
                        img.onload = function () { pasted(img); };
                    }
                }
            }
        }
    };
    if (ischrome) {
        document.addEventListener("paste", apipasted);
    }
    else {
        var catcher = document.createElement("div");
        catcher.setAttribute("contenteditable", "");
        catcher.className = "forcehidden"; //retarded ie safety/bug, cant apply styles using js//TODO i don't even know what's going on
        catcher.onpaste = function (e) {
            if (e.clipboardData && e.clipboardData.items) {
                apipasted(e);
                return;
            }
            setTimeout(function () {
                var b = catcher.children[0];
                if (!b || b.tagName != "IMG") {
                    return;
                }
                var img = new Image();
                img.src = b.src;
                var a = img.src.match(/^data:([\w\/]+);/);
                if (img.width > 0) {
                    pasted(img);
                }
                else {
                    img.onload = function () { pasted(img); };
                }
                catcher.innerHTML = "";
            }, 1);
        };
        document.body.appendChild(catcher);
    }
    //detect if ctrl-v is pressed and focus catcher if needed
    document.addEventListener("keydown", function (e) {
        if (e.target.tagName == "INPUT") {
            return;
        }
        if (e.keyCode != "V".charCodeAt(0) || !e.ctrlKey) {
            return;
        }
        pasting = true;
        setTimeout(function () {
            if (pasting) {
                error("noimg", "You pressed Ctrl+V, but no image was pasted by your browser, make sure your clipboard contains an image, and not a link to an image.");
            }
        }, 1000);
        if (catcher) {
            catcher.focus();
        }
    });
}
exports.start = start;
function fileDialog() {
    var fileinput = document.createElement("input");
    fileinput.type = "file";
    fileinput.accept = "image/png";
    fileinput.onchange = function () { if (fileinput.files && fileinput.files[0]) {
        fromFile(fileinput.files[0]);
    } };
    fileinput.click();
    return fileinput;
}
exports.fileDialog = fileDialog;
function fromFile(file) {
    if (!file) {
        return;
    }
    var reader = new FileReader();
    reader.onload = function () {
        var bytearray = new Uint8Array(reader.result);
        if (ImageDetect.isPngBuffer(bytearray)) {
            ImageDetect.clearPngColorspace(bytearray);
        }
        var blob = new Blob([bytearray], { type: "image/png" });
        var img = new Image();
        img.onerror = () => error("invalidfile", "The file you uploaded could not be opened as an image.");
        var bloburl = URL.createObjectURL(blob);
        img.src = bloburl;
        if (img.width > 0) {
            pasted(img);
            URL.revokeObjectURL(bloburl);
        }
        else {
            img.onload = function () { pasted(img); URL.revokeObjectURL(bloburl); };
        }
    };
    reader.readAsArrayBuffer(file);
}


/***/ }),

/***/ "./src/base/rect.ts":
/*!**************************!*\
  !*** ./src/base/rect.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {


//util class for rectangle maths
//TODO shit this sucks can we remove it again?
//more of a shorthand to get {x,y,width,height} than a class
//kinda starting to like it again
//TODO remove rant
Object.defineProperty(exports, "__esModule", ({ value: true }));
;
/**
 * Simple rectangle class with some util functions
 */
class Rect {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.width = w;
        this.height = h;
    }
    static fromArgs(...args) {
        if (typeof args[0] == "object") {
            return new Rect(args[0].x, args[0].y, args[0].width, args[0].height);
        }
        else if (typeof args[0] == "number" && args.length >= 4) {
            return new Rect(args[0], args[1], args[2], args[3]);
        }
        else {
            throw new Error("invalid rect args");
        }
    }
    /**
     * Resizes this Rect to include the full size of a given second rectangle
     */
    union(r2) {
        var x = Math.min(this.x, r2.x);
        var y = Math.min(this.y, r2.y);
        this.width = Math.max(this.x + this.width, r2.x + r2.width) - x;
        this.height = Math.max(this.y + this.height, r2.y + r2.height) - y;
        this.x = x;
        this.y = y;
        return this;
    }
    /**
     * Resizes this Rect to include a given point
     */
    includePoint(x, y) {
        this.union(new Rect(x, y, 0, 0));
    }
    /**
     * Grows the rectangle with the given dimensions
     */
    inflate(w, h) {
        this.x -= w;
        this.y -= h;
        this.width += 2 * w;
        this.height += 2 * h;
    }
    /**
     * Resizes this Rect to the area that overlaps a given Rect
     * width and height will be set to 0 if the intersection does not exist
     */
    intersect(r2) {
        if (this.x < r2.x) {
            this.width -= r2.x - this.x;
            this.x = r2.x;
        }
        if (this.y < r2.y) {
            this.height -= r2.y - this.y;
            this.y = r2.y;
        }
        this.width = Math.min(this.x + this.width, r2.x + r2.width) - this.x;
        this.height = Math.min(this.y + this.height, r2.y + r2.height) - this.y;
        if (this.width <= 0 || this.height <= 0) {
            this.width = 0;
            this.height = 0;
        }
    }
    /**
     * Returns wether this Rect has at least one pixel overlap with a given Rect
     */
    overlaps(r2) {
        return this.x < r2.x + r2.width && this.x + this.width > r2.x && this.y < r2.y + r2.height && this.y + this.height > r2.y;
    }
    /**
     * Returns wether a given Rect fits completely inside this Rect
     * @param r2
     */
    contains(r2) {
        return this.x <= r2.x && this.x + this.width >= r2.x + r2.width && this.y <= r2.y && this.y + this.height >= r2.y + r2.height;
    }
    /**
     * Returns wether a given point lies inside this Rect
     */
    containsPoint(x, y) {
        return this.x <= x && this.x + this.width > x && this.y <= y && this.y + this.height > y;
    }
}
exports["default"] = Rect;


/***/ }),

/***/ "./src/base/wrapper.ts":
/*!*****************************!*\
  !*** ./src/base/wrapper.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_56486__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.captureStream = exports.captureMultiAsync = exports.captureAsync = exports.ImageStreamReader = exports.once = exports.removeListener = exports.on = exports.addResizeElement = exports.getMousePosition = exports.hasAlt1Version = exports.resetEnvironment = exports.identifyApp = exports.unmixColor = exports.mixColor = exports.encodeImageString = exports.decodeImageString = exports.transferImageData = exports.captureHoldFullRs = exports.captureHoldScreen = exports.captureHold = exports.capture = exports.getdisplaybounds = exports.requireAlt1 = exports.openbrowser = exports.skinName = exports.hasAlt1 = exports.newestversion = exports.Alt1Error = exports.NoAlt1Error = void 0;
const rect_1 = __importDefault(__nested_webpack_require_56486__(/*! ./rect */ "./src/base/rect.ts"));
const imgref_1 = __nested_webpack_require_56486__(/*! ./imgref */ "./src/base/imgref.ts");
const imagedata_extensions_1 = __nested_webpack_require_56486__(/*! ./imagedata-extensions */ "./src/base/imagedata-extensions.ts");
__nested_webpack_require_56486__(/*! ./alt1api */ "./src/base/alt1api.ts");
/**
 * Thrown when a method is called that can not be used outside of Alt1
 */
class NoAlt1Error extends Error {
    constructor() {
        super();
        this.message = "This method can not be ran outside of Alt1";
    }
}
exports.NoAlt1Error = NoAlt1Error;
;
/**
 * Thrown when the Alt1 API returns an invalid result
 * Errors of a different type are throw when internal Alt1 errors occur
 */
class Alt1Error extends Error {
}
exports.Alt1Error = Alt1Error;
/**
 * The latest Alt1 version
 */
exports.newestversion = "1.5.5";
/**
 * Whether the Alt1 API is available
 */
exports.hasAlt1 = (typeof alt1 != "undefined");
/**
 * The name of the Alt1 interface skin. (Always "default" if running in a browser)
 */
exports.skinName = exports.hasAlt1 ? alt1.skinName : "default";
/**
 * Max number of bytes that can be sent by alt1 in one function
 * Not completely sure why this number is different than window.alt1.maxtranfer
 */
var maxtransfer = 4000000;
/**
 * Open a link in the default browser
 * @deprecated use window.open instead
 */
function openbrowser(url) {
    if (exports.hasAlt1) {
        alt1.openBrowser(url);
    }
    else {
        window.open(url, '_blank');
    }
}
exports.openbrowser = openbrowser;
/**
 * Throw if Alt1 API is not available
 */
function requireAlt1() {
    if (!exports.hasAlt1) {
        throw new NoAlt1Error();
    }
}
exports.requireAlt1 = requireAlt1;
/**
 * Returns an object with a rectangle that spans all screens
 */
function getdisplaybounds() {
    if (!exports.hasAlt1) {
        return false;
    }
    return new rect_1.default(alt1.screenX, alt1.screenY, alt1.screenWidth, alt1.screenHeight);
}
exports.getdisplaybounds = getdisplaybounds;
/**
 * gets an imagebuffer with pixel data about the requested region
 */
function capture(...args) {
    //TODO change null return on error into throw instead (x3)
    if (!exports.hasAlt1) {
        throw new NoAlt1Error();
    }
    var rect = rect_1.default.fromArgs(...args);
    if (alt1.capture) {
        return new imagedata_extensions_1.ImageData(alt1.capture(rect.x, rect.y, rect.width, rect.height), rect.width, rect.height);
    }
    var buf = new imagedata_extensions_1.ImageData(rect.width, rect.height);
    if (rect.width * rect.height * 4 <= maxtransfer) {
        var data = alt1.getRegion(rect.x, rect.y, rect.width, rect.height);
        if (!data) {
            return null;
        }
        decodeImageString(data, buf, 0, 0, rect.width, rect.height);
    }
    else {
        //split up the request to to exceed the single transfer limit (for now)
        var x1 = rect.x;
        var ref = alt1.bindRegion(rect.x, rect.y, rect.width, rect.height);
        if (ref <= 0) {
            return null;
        }
        while (x1 < rect.x + rect.width) {
            var x2 = Math.min(rect.x + rect.width, Math.floor(x1 + (maxtransfer / 4 / rect.height)));
            var data = alt1.bindGetRegion(ref, x1, rect.y, x2 - x1, rect.height);
            if (!data) {
                return null;
            }
            decodeImageString(data, buf, x1 - rect.x, 0, x2 - x1, rect.height);
            x1 = x2;
        }
    }
    return buf;
}
exports.capture = capture;
/**
 * Makes alt1 bind an area of the rs client in memory without sending it to the js client
 * returns an imgref object which can be used to get pixel data using the imgreftobuf function
 * currently only one bind can exist per app and the ref in (v) will always be 1
 */
function captureHold(x, y, w, h) {
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    requireAlt1();
    var r = alt1.bindRegion(x, y, w, h);
    if (r <= 0) {
        throw new Alt1Error("capturehold failed");
    }
    return new imgref_1.ImgRefBind(r, x, y, w, h);
}
exports.captureHold = captureHold;
/**
 * Same as captureHoldRegion, but captures the screen instead of the rs client. it also uses screen coordinates instead and can capture outside of the rs client
 */
function captureHoldScreen(x, y, w, h) {
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    requireAlt1();
    var r = alt1.bindScreenRegion(x, y, w, h);
    if (r <= 0) {
        return false;
    }
    return new imgref_1.ImgRefBind(r, x, y, w, h);
}
exports.captureHoldScreen = captureHoldScreen;
/**
 * bind the full rs window if the rs window can be detected by alt1, otherwise return the full screen
 */
function captureHoldFullRs() {
    return captureHold(0, 0, alt1.rsWidth, alt1.rsHeight);
}
exports.captureHoldFullRs = captureHoldFullRs;
/**
 * returns a subregion from a bound image
 * used internally in imgreftobuf if imgref is a bound image
 * @deprecated This should be handled internall by the imgrefbind.toData method
 */
function transferImageData(handle, x, y, w, h) {
    x = Math.round(x);
    y = Math.round(y);
    w = Math.round(w);
    h = Math.round(h);
    requireAlt1();
    if (alt1.bindGetRegionBuffer) {
        return new imagedata_extensions_1.ImageData(alt1.bindGetRegionBuffer(handle, x, y, w, h), w, h);
    }
    var r = new imagedata_extensions_1.ImageData(w, h);
    var x1 = x;
    while (true) { //split up the request to to exceed the single transfer limit (for now)
        var x2 = Math.min(x + w, Math.floor(x1 + (maxtransfer / 4 / h)));
        var a = alt1.bindGetRegion(handle, x1, y, x2 - x1, h);
        if (!a) {
            throw new Alt1Error();
        }
        decodeImageString(a, r, x1 - x, 0, x2 - x1, h);
        x1 = x2;
        if (x1 == x + w) {
            break;
        }
        ;
    }
    return r;
}
exports.transferImageData = transferImageData;
/**
 * decodes a returned string from alt1 to an imagebuffer
 */
function decodeImageString(imagestring, target, x, y, w, h) {
    var bin = atob(imagestring);
    var bytes = target.data;
    w |= 0;
    h |= 0;
    var offset = 4 * x + 4 * y * target.width;
    var target_width = target.width | 0;
    for (var a = 0; a < w; a++) {
        for (var b = 0; b < h; b++) {
            var i1 = (offset + (a * 4 | 0) + (b * target_width * 4 | 0)) | 0;
            var i2 = ((a * 4 | 0) + (b * 4 * w | 0)) | 0;
            bytes[i1 + 0 | 0] = bin.charCodeAt(i2 + 2 | 0); //fix weird red/blue swap in c#
            bytes[i1 + 1 | 0] = bin.charCodeAt(i2 + 1 | 0);
            bytes[i1 + 2 | 0] = bin.charCodeAt(i2 + 0 | 0);
            bytes[i1 + 3 | 0] = bin.charCodeAt(i2 + 3 | 0);
        }
    }
    return target;
}
exports.decodeImageString = decodeImageString;
/**
 * encodes an imagebuffer to a string
 */
function encodeImageString(buf, sx = 0, sy = 0, sw = buf.width, sh = buf.height) {
    var raw = "";
    for (var y = sy; y < sy + sh; y++) {
        for (var x = sx; x < sx + sw; x++) {
            var i = 4 * x + 4 * buf.width * y | 0;
            raw += String.fromCharCode(buf.data[i + 2 | 0]);
            raw += String.fromCharCode(buf.data[i + 1 | 0]);
            raw += String.fromCharCode(buf.data[i + 0 | 0]);
            raw += String.fromCharCode(buf.data[i + 3 | 0]);
        }
    }
    return btoa(raw);
}
exports.encodeImageString = encodeImageString;
/**
 * mixes the given color into a single int. This format is used by alt1
 */
function mixColor(r, g, b, a = 255) {
    return (b << 0) + (g << 8) + (r << 16) + (a << 24);
}
exports.mixColor = mixColor;
function unmixColor(col) {
    var r = (col >> 16) & 0xff;
    var g = (col >> 8) & 0xff;
    var b = (col >> 0) & 0xff;
    return [r, g, b];
}
exports.unmixColor = unmixColor;
function identifyApp(url) {
    if (exports.hasAlt1) {
        alt1.identifyAppUrl(url);
    }
}
exports.identifyApp = identifyApp;
function resetEnvironment() {
    exports.hasAlt1 = (typeof alt1 != "undefined");
    exports.skinName = exports.hasAlt1 ? alt1.skinName : "default";
}
exports.resetEnvironment = resetEnvironment;
function convertAlt1Version(str) {
    var a = str.match(/^(\d+)\.(\d+)\.(\d+)$/);
    if (!a) {
        throw new RangeError("Invalid version string");
    }
    return (+a[1]) * 1000 * 1000 + (+a[2]) * 1000 + (+a[3]) * 1;
}
var cachedVersionInt = -1;
/**
 * checks if alt1 is running and at least the given version. versionstr should be a string with the version eg: 1.3.2
 * @param versionstr
 */
function hasAlt1Version(versionstr) {
    if (!exports.hasAlt1) {
        return false;
    }
    if (cachedVersionInt == -1) {
        cachedVersionInt = alt1.versionint;
    }
    return cachedVersionInt >= convertAlt1Version(versionstr);
}
exports.hasAlt1Version = hasAlt1Version;
/**
 * Gets the current cursor position in the game, returns null if the rs window is not active (alt1.rsActive)
 */
function getMousePosition() {
    var pos = alt1.mousePosition;
    if (pos == -1) {
        return null;
    }
    return { x: pos >>> 16, y: pos & 0xFFFF };
}
exports.getMousePosition = getMousePosition;
/**
 * Registers a given HTML element as a frame border, when this element is dragged by the user the Alt1 frame will resize accordingly
 * Use the direction arguements to make a given direction stick to the mouse. eg. Only set left to true to make the element behave as the left border
 * Or set all to true to move the whole window. Not all combinations are permitted
 */
function addResizeElement(el, left, top, right, bot) {
    if (!exports.hasAlt1 || !alt1.userResize) {
        return;
    }
    el.addEventListener("mousedown", function (e) {
        alt1.userResize(left, top, right, bot);
        e.preventDefault();
    });
}
exports.addResizeElement = addResizeElement;
/**
 * Add an event listener
 */
function on(type, listener) {
    if (!exports.hasAlt1) {
        return;
    }
    if (!alt1.events) {
        alt1.events = {};
    }
    if (!alt1.events[type]) {
        alt1.events[type] = [];
    }
    alt1.events[type].push(listener);
}
exports.on = on;
/**
 * Removes an event listener
 */
function removeListener(type, listener) {
    var elist = exports.hasAlt1 && alt1.events && alt1.events[type];
    if (!elist) {
        return;
    }
    var i = elist.indexOf(listener);
    if (i == -1) {
        return;
    }
    elist.splice(i, 1);
}
exports.removeListener = removeListener;
/**
 * Listens for the event to fire once and then stops listening
 * @param event
 * @param cb
 */
function once(type, listener) {
    var fn = (e) => {
        removeListener(type, fn);
        listener(e);
    };
    on(type, fn);
}
exports.once = once;
;
/**
 * Used to read a set of images from a binary stream returned by the Alt1 API
 */
class ImageStreamReader {
    constructor(reader, ...args) {
        this.framebuffer = null;
        this.pos = 0;
        this.reading = false;
        this.closed = false;
        //paused state
        this.pausedindex = -1;
        this.pausedbuffer = null;
        this.streamreader = reader;
        if (args[0] instanceof imagedata_extensions_1.ImageData) {
            this.setFrameBuffer(args[0]);
        }
        else if (typeof args[0] == "number") {
            this.setFrameBuffer(new imagedata_extensions_1.ImageData(args[0], args[1]));
        }
    }
    /**
     *
     */
    setFrameBuffer(buffer) {
        if (this.reading) {
            throw new Error("can't change framebuffer while reading");
        }
        this.framebuffer = buffer;
    }
    /**
     * Closes the underlying stream and ends reading
     */
    close() {
        this.streamreader.cancel();
    }
    /**
     * Reads a single image from the stream
     */
    async nextImage() {
        if (this.reading) {
            throw new Error("already reading from this stream");
        }
        if (!this.framebuffer) {
            throw new Error("framebuffer not set");
        }
        this.reading = true;
        var synctime = -Date.now();
        var starttime = Date.now();
        var r = false;
        while (!r) {
            if (this.pausedindex != -1 && this.pausedbuffer) {
                r = this.readChunk(this.pausedindex, this.framebuffer.data, this.pausedbuffer);
            }
            else {
                synctime += Date.now();
                var res = await this.streamreader.read();
                synctime -= Date.now();
                if (res.done) {
                    throw new Error("Stream closed while reading");
                }
                var data = res.value;
                r = this.readChunk(0, this.framebuffer.data, data);
            }
        }
        synctime += Date.now();
        //console.log("Decoded async image, " + this.framebuffer.width + "x" + this.framebuffer.height + " time: " + (Date.now() - starttime) + "ms (" + synctime + "ms main thread)");
        this.reading = false;
        return this.framebuffer;
    }
    readChunk(i, framedata, buffer) {
        //very hot code, explicit int32 casting with |0 speeds it up by ~ x2
        i = i | 0;
        var framesize = framedata.length | 0;
        var pos = this.pos;
        var datalen = buffer.length | 0;
        //var data32 = new Float64Array(buffer.buffer);
        //var framedata32 = new Float64Array(framedata.buffer);
        //fix possible buffer misalignment
        //align to 16 for extra loop unrolling
        while (i < datalen) {
            //slow loop, fix alignment and other issues
            while (i < datalen && pos < framesize && (pos % 16 != 0 || !((i + 16 | 0) <= datalen && (pos + 16 | 0) <= framesize))) {
                var rel = pos;
                if (pos % 4 == 0) {
                    rel = rel + 2 | 0;
                }
                if (pos % 4 == 2) {
                    rel = rel - 2 | 0;
                }
                framedata[rel | 0] = buffer[i | 0];
                i = i + 1 | 0;
                pos = pos + 1 | 0;
            }
            //fast unrolled loop for large chunks i wish js had some sort of memcpy
            if (pos % 16 == 0) {
                while ((i + 16 | 0) <= datalen && (pos + 16 | 0) <= framesize) {
                    framedata[pos + 0 | 0] = buffer[i + 2 | 0];
                    framedata[pos + 1 | 0] = buffer[i + 1 | 0];
                    framedata[pos + 2 | 0] = buffer[i + 0 | 0];
                    framedata[pos + 3 | 0] = buffer[i + 3 | 0];
                    framedata[pos + 4 | 0] = buffer[i + 6 | 0];
                    framedata[pos + 5 | 0] = buffer[i + 5 | 0];
                    framedata[pos + 6 | 0] = buffer[i + 4 | 0];
                    framedata[pos + 7 | 0] = buffer[i + 7 | 0];
                    framedata[pos + 8 | 0] = buffer[i + 10 | 0];
                    framedata[pos + 9 | 0] = buffer[i + 9 | 0];
                    framedata[pos + 10 | 0] = buffer[i + 8 | 0];
                    framedata[pos + 11 | 0] = buffer[i + 11 | 0];
                    framedata[pos + 12 | 0] = buffer[i + 14 | 0];
                    framedata[pos + 13 | 0] = buffer[i + 13 | 0];
                    framedata[pos + 14 | 0] = buffer[i + 12 | 0];
                    framedata[pos + 15 | 0] = buffer[i + 15 | 0];
                    //could speed it up another x2 but wouldn't be able to swap r/b swap and possible alignment issues
                    //framedata32[pos / 8 + 0 | 0] = data32[i / 8 + 0 | 0];
                    //framedata32[pos / 8 + 1 | 0] = data32[i / 8 + 1 | 0];
                    //framedata32[pos / 4 + 2 | 0] = data32[i / 4 + 2 | 0];
                    //framedata32[pos / 4 + 3 | 0] = data32[i / 4 + 3 | 0];
                    pos = pos + 16 | 0;
                    i = i + 16 | 0;
                }
            }
            if (pos >= framesize) {
                this.pausedbuffer = null;
                this.pausedindex = -1;
                this.pos = 0;
                if (i != buffer.length - 1) {
                    this.pausedbuffer = buffer;
                    this.pausedindex = i;
                }
                return true;
            }
        }
        this.pos = pos;
        this.pausedbuffer = null;
        this.pausedindex = -1;
        return false;
    }
}
exports.ImageStreamReader = ImageStreamReader;
/**
 * Asynchronously captures a section of the game screen
 */
async function captureAsync(...args) {
    requireAlt1();
    var rect = rect_1.default.fromArgs(...args);
    if (alt1.captureAsync) {
        let img = await alt1.captureAsync(rect.x, rect.y, rect.width, rect.height);
        return new imagedata_extensions_1.ImageData(img, rect.width, rect.height);
    }
    if (!hasAlt1Version("1.4.6")) {
        return capture(rect.x, rect.y, rect.width, rect.height);
    }
    var url = "https://alt1api/pixel/getregion/" + encodeURIComponent(JSON.stringify(Object.assign(Object.assign({}, rect), { format: "raw", quality: 1 })));
    var res = await fetch(url);
    var imgreader = new ImageStreamReader(res.body.getReader(), rect.width, rect.height);
    return imgreader.nextImage();
}
exports.captureAsync = captureAsync;
/**
 * Asynchronously captures multple area's. This method captures the images in the same render frame if possible
 * @param areas
 */
async function captureMultiAsync(areas) {
    requireAlt1();
    var r = {};
    if (alt1.captureMultiAsync) {
        let bufs = await alt1.captureMultiAsync(areas);
        for (let a in areas) {
            if (!bufs[a]) {
                r[a] = null;
            }
            r[a] = new imagedata_extensions_1.ImageData(bufs[a], areas[a].width, areas[a].height);
        }
        return r;
    }
    var capts = [];
    var captids = [];
    for (var id in areas) {
        if (areas[id]) {
            capts.push(areas[id]);
            captids.push(id);
        }
        else {
            r[id] = null;
        }
    }
    if (capts.length == 0) {
        return r;
    }
    if (!hasAlt1Version("1.5.1")) {
        var proms = [];
        for (var a = 0; a < capts.length; a++) {
            proms.push(captureAsync(capts[a]));
        }
        var results = await Promise.all(proms);
        for (var a = 0; a < capts.length; a++) {
            r[captids[a]] = results[a];
        }
    }
    else {
        var res = await fetch("https://alt1api/pixel/getregionmulti/" + encodeURIComponent(JSON.stringify({ areas: capts, format: "raw", quality: 1 })));
        var imgreader = new ImageStreamReader(res.body.getReader());
        for (var a = 0; a < capts.length; a++) {
            var capt = capts[a];
            imgreader.setFrameBuffer(new imagedata_extensions_1.ImageData(capt.width, capt.height));
            r[captids[a]] = await imgreader.nextImage();
        }
    }
    return r;
}
exports.captureMultiAsync = captureMultiAsync;
/**
 * Starts capturing a realtime stream of the game. Make sure you keep reading the stream and close it when you're done or Alt1 WILL crash
 * @param framecb Called whenever a new frame is decoded
 * @param errorcb Called whenever an error occurs, the error is rethrown if not defined
 * @param fps Maximum fps of the stream
 */
function captureStream(x, y, width, height, fps, framecb, errorcb) {
    requireAlt1();
    if (!hasAlt1Version("1.4.6")) {
        throw new Alt1Error("This function is not supported in this version of Alt1");
    }
    var url = "https://alt1api/pixel/streamregion/" + encodeURIComponent(JSON.stringify({ x, y, width, height, fps, format: "raw" }));
    var res = fetch(url).then(async (res) => {
        var reader = new ImageStreamReader(res.body.getReader(), width, height);
        try {
            while (!reader.closed && !state.closed) {
                var img = await reader.nextImage();
                if (!state.closed) {
                    framecb(img);
                    state.framenr++;
                }
            }
        }
        catch (e) {
            if (!state.closed) {
                reader.close();
                if (errorcb) {
                    errorcb(e);
                }
                else {
                    throw e;
                }
            }
        }
        if (!reader.closed && state.closed) {
            reader.close();
        }
    });
    var state = {
        x, y, width, height,
        framenr: 0,
        close: () => { state.closed = true; },
        closed: false,
    };
    return state;
}
exports.captureStream = captureStream;


/***/ }),

/***/ "canvas":
/*!*************************!*\
  !*** external "canvas" ***!
  \*************************/
/***/ ((module) => {

if(typeof __WEBPACK_EXTERNAL_MODULE_canvas__ === 'undefined') { var e = new Error("Cannot find module 'canvas'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE_canvas__;

/***/ }),

/***/ "electron/common":
/*!**********************************!*\
  !*** external "electron/common" ***!
  \**********************************/
/***/ ((module) => {

if(typeof __WEBPACK_EXTERNAL_MODULE_electron_common__ === 'undefined') { var e = new Error("Cannot find module 'electron/common'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE_electron_common__;

/***/ }),

/***/ "sharp":
/*!************************!*\
  !*** external "sharp" ***!
  \************************/
/***/ ((module) => {

if(typeof __WEBPACK_EXTERNAL_MODULE_sharp__ === 'undefined') { var e = new Error("Cannot find module 'sharp'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = __WEBPACK_EXTERNAL_MODULE_sharp__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_79245__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_79245__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__nested_webpack_require_79245__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_79245__("./src/base/index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "../node_modules/alt1/dist/buffs/index.js":
/*!************************************************!*\
  !*** ../node_modules/alt1/dist/buffs/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js"), __webpack_require__(/*! alt1/ocr */ "../node_modules/alt1/dist/ocr/index.js"));
	else {}
})(globalThis, (__WEBPACK_EXTERNAL_MODULE_alt1_base__, __WEBPACK_EXTERNAL_MODULE_alt1_ocr__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/buffs/imgs/buffborder.data.png":
/*!********************************************!*\
  !*** ./src/buffs/imgs/buffborder.data.png ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_885__) => {

module.exports=(__nested_webpack_require_885__(/*! alt1/base */ "alt1/base").ImageDetect.imageDataFromBase64)("iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAYAAACN1PRVAAAAAW5vUEUAYtdMlAAAAARub1BFAAAAAEEgjiIAAAAJbm9QRQAAAAAAAAAAAKGKctUAAABCSURBVEhL7daxDQAgDANBwxasxmCsS4jECE8K5JdcX+s219iqKrGTXi+dfs2SjCEZQzKGZAzJGJIxJGNI/2KFj1gK6ntTCO2Nfp8AAAAASUVORK5CYII=")

/***/ }),

/***/ "./src/buffs/imgs/debuffborder.data.png":
/*!**********************************************!*\
  !*** ./src/buffs/imgs/debuffborder.data.png ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1504__) => {

module.exports=(__nested_webpack_require_1504__(/*! alt1/base */ "alt1/base").ImageDetect.imageDataFromBase64)("iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAYAAACN1PRVAAAAAW5vUEUAYtdMlAAAAARub1BFAAAAAEEgjiIAAAAJbm9QRQAAAAAAAAAAAKGKctUAAABFSURBVEhL7daxDQAgDANBm5XYfwOYyUgoI5gUyFc51bfhAoQmNzYl1v3MJjVqt0jMIjGLxCwSs0jMIjGLxCz+jTV+xMAB3/oJlYh5IBUAAAAASUVORK5CYII=")

/***/ }),

/***/ "./src/buffs/index.ts":
/*!****************************!*\
  !*** ./src/buffs/index.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_2063__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuffInfo = exports.Buff = void 0;
const a1lib = __importStar(__nested_webpack_require_2063__(/*! alt1/base */ "alt1/base"));
const OCR = __importStar(__nested_webpack_require_2063__(/*! alt1/ocr */ "alt1/ocr"));
const base_1 = __nested_webpack_require_2063__(/*! alt1/base */ "alt1/base");
var imgs = (0, base_1.webpackImages)({
    buff: __nested_webpack_require_2063__(/*! ./imgs/buffborder.data.png */ "./src/buffs/imgs/buffborder.data.png"),
    debuff: __nested_webpack_require_2063__(/*! ./imgs/debuffborder.data.png */ "./src/buffs/imgs/debuffborder.data.png"),
});
var font = __nested_webpack_require_2063__(/*! ../fonts/pixel_8px_digits.fontmeta.json */ "./src/fonts/pixel_8px_digits.fontmeta.json");
function negmod(a, b) {
    return ((a % b) + b) % b;
}
class Buff {
    constructor(buffer, x, y, isdebuff) {
        this.buffer = buffer;
        this.bufferx = x;
        this.buffery = y;
        this.isdebuff = isdebuff;
    }
    readArg(type) {
        return BuffReader.readArg(this.buffer, this.bufferx + 2, this.buffery + 23, type);
    }
    readTime() {
        return BuffReader.readTime(this.buffer, this.bufferx + 2, this.buffery + 23);
    }
    compareBuffer(img) {
        return BuffReader.compareBuffer(this.buffer, this.bufferx + 1, this.buffery + 1, img);
    }
    countMatch(img, aggressive) {
        return BuffReader.countMatch(this.buffer, this.bufferx + 1, this.buffery + 1, img, aggressive);
    }
}
exports.Buff = Buff;
class BuffReader {
    constructor() {
        this.pos = null;
        this.debuffs = false;
    }
    find(img) {
        if (!img) {
            img = a1lib.captureHoldFullRs();
        }
        if (!img) {
            return null;
        }
        var poslist = img.findSubimage(this.debuffs ? imgs.debuff : imgs.buff);
        if (poslist.length == 0) {
            return null;
        }
        var grids = [];
        for (var a in poslist) {
            var ongrid = false;
            for (var b in grids) {
                if (negmod(grids[b].x - poslist[a].x, BuffReader.gridsize) == 0 && negmod(grids[b].x - poslist[a].x, BuffReader.gridsize) == 0) {
                    grids[b].x = Math.min(grids[b].x, poslist[a].x);
                    grids[b].y = Math.min(grids[b].y, poslist[a].y);
                    grids[b].n++;
                    ongrid = true;
                    break;
                }
            }
            if (!ongrid) {
                grids.push({ x: poslist[a].x, y: poslist[a].y, n: 1 });
            }
        }
        var max = 0;
        var above2 = 0;
        var best = null;
        for (var a in grids) {
            console.log("buff grid [" + grids[a].x + "," + grids[a].y + "], n:" + grids[a].n);
            if (grids[a].n > max) {
                max = grids[a].n;
                best = grids[a];
            }
            if (grids[a].n >= 2) {
                above2++;
            }
        }
        if (above2 > 1) {
            console.log("Warning, more than one possible buff bar location");
        }
        if (!best) {
            return null;
        }
        this.pos = { x: best.x, y: best.y, maxhor: 5, maxver: 1 };
        return true;
    }
    getCaptRect() {
        if (!this.pos) {
            return null;
        }
        return new a1lib.Rect(this.pos.x, this.pos.y, (this.pos.maxhor + 1) * BuffReader.gridsize, (this.pos.maxver + 1) * BuffReader.gridsize);
    }
    read(buffer) {
        if (!this.pos) {
            throw new Error("no pos");
        }
        var r = [];
        var rect = this.getCaptRect();
        if (!rect) {
            return null;
        }
        if (!buffer) {
            buffer = a1lib.capture(rect.x, rect.y, rect.width, rect.height);
        }
        var maxhor = 0;
        var maxver = 0;
        for (var ix = 0; ix <= this.pos.maxhor; ix++) {
            for (var iy = 0; iy <= this.pos.maxver; iy++) {
                var x = ix * BuffReader.gridsize;
                var y = iy * BuffReader.gridsize;
                //Have to require exact match here as we get transparency bs otherwise
                var match = buffer.pixelCompare((this.debuffs ? imgs.debuff : imgs.buff), x, y) == 0;
                if (!match) {
                    break;
                }
                r.push(new Buff(buffer, x, y, this.debuffs));
                maxhor = Math.max(maxhor, ix);
                maxver = Math.max(maxver, iy);
            }
        }
        this.pos.maxhor = Math.max(5, maxhor + 2);
        this.pos.maxver = Math.max(1, maxver + 1);
        return r;
    }
    static compareBuffer(buffer, ox, oy, buffimg) {
        var r = BuffReader.countMatch(buffer, ox, oy, buffimg, true);
        if (r.failed > 0) {
            return false;
        }
        if (r.tested < 50) {
            return false;
        }
        return true;
    }
    static countMatch(buffer, ox, oy, buffimg, agressive) {
        var r = { tested: 0, failed: 0, skipped: 0, passed: 0 };
        var data1 = buffer.data;
        var data2 = buffimg.data;
        //var debug = new ImageData(buffimg.width, buffimg.height);
        for (var y = 0; y < buffimg.height; y++) {
            for (var x = 0; x < buffimg.width; x++) {
                var i1 = buffer.pixelOffset(ox + x, oy + y);
                var i2 = buffimg.pixelOffset(x, y);
                //debug.data[i2] = 255; debug.data[i2 + 1] = debug.data[i2 + 2] = 0; debug.data[i2 + 3] = 255;
                if (data2[i2 + 3] != 255) {
                    r.skipped++;
                    continue;
                } //transparent buff pixel
                if (data1[i1] == 255 && data1[i1 + 1] == 255 && data1[i1 + 2] == 255) {
                    r.skipped++;
                    continue;
                } //white pixel - part of buff time text
                if (data1[i1] == 0 && data1[i1 + 1] == 0 && data1[i1 + 2] == 0) {
                    r.skipped++;
                    continue;
                } //black pixel - part of buff time text
                var d = a1lib.ImageDetect.coldif(data1[i1], data1[i1 + 1], data1[i1 + 2], data2[i2], data2[i2 + 1], data2[i2 + 2], 255);
                r.tested++;
                //debug.data[i2] = debug.data[i2 + 1] = debug.data[i2 + 2] = d * 10;
                if (d > 35) {
                    //qw(pixelschecked); debug.show();
                    r.failed++;
                    if (agressive) {
                        return r;
                    }
                }
                else {
                    r.passed++;
                }
            }
        }
        //debug.show(); qw(pixelschecked);
        return r;
    }
    static isolateBuffer(buffer, ox, oy, buffimg) {
        var count = BuffReader.countMatch(buffer, ox, oy, buffimg);
        if (count.passed < 50) {
            return;
        }
        var removed = 0;
        var data1 = buffer.data;
        var data2 = buffimg.data;
        //var debug = new ImageData(buffimg.width, buffimg.height);
        for (var y = 0; y < buffimg.height; y++) {
            for (var x = 0; x < buffimg.width; x++) {
                var i1 = buffer.pixelOffset(ox + x, oy + y);
                var i2 = buffimg.pixelOffset(x, y);
                //debug.data[i2] = 255; debug.data[i2 + 1] = debug.data[i2 + 2] = 0; debug.data[i2 + 3] = 255;
                if (data2[i2 + 3] != 255) {
                    continue;
                } //transparent buff pixel
                //==== new buffer has text on it ====
                if (data1[i1] == 255 && data1[i1 + 1] == 255 && data1[i1 + 2] == 255 || data1[i1] == 0 && data1[i1 + 1] == 0 && data1[i1 + 2] == 0) {
                    continue;
                }
                //==== old buf has text on it, use the new one ====
                if (data2[i2] == 255 && data2[i2 + 1] == 255 && data2[i2 + 2] == 255 || data2[i2] == 0 && data2[i2 + 1] == 0 && data2[i2 + 2] == 0) {
                    data2[i2 + 0] = data1[i1 + 0];
                    data2[i2 + 1] = data1[i1 + 1];
                    data2[i2 + 2] = data1[i1 + 2];
                    data2[i2 + 3] = data1[i1 + 3];
                    removed++;
                }
                var d = a1lib.ImageDetect.coldif(data1[i1], data1[i1 + 1], data1[i1 + 2], data2[i2], data2[i2 + 1], data2[i2 + 2], 255);
                //debug.data[i2] = debug.data[i2 + 1] = debug.data[i2 + 2] = d * 10;
                if (d > 5) {
                    //qw(pixelschecked); debug.show();
                    data2[i2 + 0] = data2[i2 + 1] = data2[i2 + 2] = data2[i2 + 3] = 0;
                    removed++;
                }
            }
        }
        //debug.show(); qw(pixelschecked);
        if (removed > 0) {
            console.log(removed + " pixels remove from buff template image");
        }
    }
    static readArg(buffer, ox, oy, type) {
        var lines = [];
        for (var dy = -10; dy < 10; dy += 10) { //the timer can be spread to a second line at certain times (229m)
            var result = OCR.readLine(buffer, font, [255, 255, 255], ox, oy + dy, true);
            if (result.text) {
                lines.push(result.text);
            }
        }
        var r = { time: 0, arg: "" };
        if (type == "timearg" && lines.length > 1) {
            r.arg = lines.pop();
        }
        var str = lines.join("");
        if (type == "arg") {
            r.arg = str;
        }
        else {
            var m;
            if (m = str.match(/^(\d+)hr$/i)) {
                r.time = +m[1] * 60 * 60;
            }
            else if (m = str.match(/^(\d+)m$/i)) {
                r.time = +m[1] * 60;
            }
            else if (m = str.match(/^(\d+)$/)) {
                r.time = +m[1];
            }
        }
        return r;
    }
    static readTime(buffer, ox, oy) {
        return this.readArg(buffer, ox, oy, "time").time;
    }
    static matchBuff(state, buffimg) {
        for (var a in state) {
            if (state[a].compareBuffer(buffimg)) {
                return state[a];
            }
        }
        return null;
    }
    static matchBuffMulti(state, buffinfo) {
        if (buffinfo.final) { //cheap way if we known exactly what we're searching for
            return BuffReader.matchBuff(state, buffinfo.imgdata);
        }
        else { //expensive way if we are not sure the template is final
            var bestindex = -1;
            var bestscore = 0;
            if (buffinfo.imgdata) {
                for (var a = 0; a < state.length; a++) {
                    var count = BuffReader.countMatch(state[a].buffer, state[a].bufferx + 1, state[a].buffery + 1, buffinfo.imgdata, false);
                    if (count.passed > bestscore) {
                        bestscore = count.passed;
                        bestindex = a;
                    }
                }
            }
            if (bestscore < 50) {
                return null;
            }
            //update the isolated buff
            if (buffinfo.canimprove) {
                BuffReader.isolateBuffer(state[bestindex].buffer, state[bestindex].bufferx + 1, state[bestindex].buffery + 1, buffinfo.imgdata);
            }
            return state[bestindex];
        }
    }
}
BuffReader.buffsize = 27;
BuffReader.gridsize = 30;
exports["default"] = BuffReader;
class BuffInfo {
    constructor(imgdata, debuff, id, canimprove) {
        this.imgdata = imgdata;
        this.isdebuff = debuff;
        this.buffid = id;
        this.final = !!id && !canimprove;
        this.canimprove = canimprove;
    }
}
exports.BuffInfo = BuffInfo;


/***/ }),

/***/ "alt1/base":
/*!**************************************************************************************************!*\
  !*** external {"root":"A1lib","commonjs2":"alt1/base","commonjs":"alt1/base","amd":"alt1/base"} ***!
  \**************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_alt1_base__;

/***/ }),

/***/ "alt1/ocr":
/*!*********************************************************************************************!*\
  !*** external {"root":"OCR","commonjs2":"alt1/ocr","commonjs":"alt1/ocr","amd":"alt1/ocr"} ***!
  \*********************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_alt1_ocr__;

/***/ }),

/***/ "./src/fonts/pixel_8px_digits.fontmeta.json":
/*!**************************************************!*\
  !*** ./src/fonts/pixel_8px_digits.fontmeta.json ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"chars":[{"width":7,"bonus":120,"chr":"0","pixels":[0,2,255,255,0,3,255,255,0,4,255,255,0,5,255,255,1,1,255,255,1,3,255,0,1,4,255,0,1,5,255,0,1,6,255,255,2,0,255,255,2,2,255,0,2,7,255,255,3,1,255,255,3,6,255,255,3,8,255,0,4,2,255,255,4,3,255,255,4,4,255,255,4,5,255,255,4,7,255,0,5,3,255,0,5,4,255,0,5,5,255,0,5,6,255,0],"secondary":false},{"width":4,"bonus":95,"chr":"1","pixels":[0,1,255,255,0,7,255,255,1,0,255,255,1,1,255,255,1,2,255,255,1,3,255,255,1,4,255,255,1,5,255,255,1,6,255,255,1,7,255,255,1,8,255,0,2,1,255,0,2,2,255,0,2,3,255,0,2,4,255,0,2,5,255,0,2,6,255,0,2,7,255,255,2,8,255,0],"secondary":false},{"width":7,"bonus":140,"chr":"2","pixels":[0,1,255,255,0,6,255,255,0,7,255,255,1,0,255,255,1,2,255,0,1,5,255,255,1,7,255,255,1,8,255,0,2,0,255,255,2,1,255,0,2,4,255,255,2,6,255,0,2,7,255,255,2,8,255,0,3,0,255,255,3,1,255,0,3,3,255,255,3,5,255,0,3,7,255,255,3,8,255,0,4,1,255,255,4,2,255,255,4,4,255,0,4,7,255,255,4,8,255,0,5,2,255,0,5,3,255,0,5,8,255,0],"secondary":false},{"width":6,"bonus":115,"chr":"3","pixels":[0,1,255,255,0,6,255,255,1,0,255,255,1,2,255,0,1,3,255,255,1,7,255,255,2,0,255,255,2,1,255,0,2,3,255,255,2,4,255,0,2,7,255,255,2,8,255,0,3,1,255,255,3,2,255,255,3,4,255,255,3,5,255,255,3,6,255,255,3,8,255,0,4,2,255,0,4,3,255,0,4,5,255,0,4,6,255,0,4,7,255,0],"secondary":false},{"width":5,"bonus":110,"chr":"4","pixels":[0,0,255,255,0,1,255,255,0,2,255,255,0,3,255,255,0,4,255,255,0,5,255,255,1,1,255,0,1,2,255,0,1,3,255,0,1,4,255,0,1,5,255,255,1,6,255,0,2,3,255,255,2,4,255,255,2,5,255,255,2,6,255,255,2,7,255,255,3,4,255,0,3,5,255,255,3,6,255,0,3,7,255,0,3,8,255,0],"secondary":false},{"width":6,"bonus":135,"chr":"5","pixels":[0,0,255,255,0,1,255,255,0,2,255,255,0,3,255,255,0,6,255,255,1,0,255,255,1,1,255,0,1,2,255,0,1,3,255,255,1,4,255,0,1,7,255,255,2,0,255,255,2,1,255,0,2,3,255,255,2,4,255,0,2,7,255,255,2,8,255,0,3,0,255,255,3,1,255,0,3,4,255,255,3,5,255,255,3,6,255,255,3,8,255,0,4,1,255,0,4,5,255,0,4,6,255,0,4,7,255,0],"secondary":false},{"width":7,"bonus":160,"chr":"6","pixels":[0,2,255,255,0,3,255,255,0,4,255,255,0,5,255,255,0,6,255,255,1,1,255,255,1,3,255,0,1,4,255,255,1,5,255,0,1,6,255,0,1,7,255,255,2,0,255,255,2,2,255,0,2,3,255,255,2,5,255,0,2,7,255,255,2,8,255,0,3,0,255,255,3,1,255,0,3,3,255,255,3,4,255,0,3,7,255,255,3,8,255,0,4,1,255,255,4,4,255,255,4,5,255,255,4,6,255,255,4,8,255,0,5,2,255,0,5,5,255,0,5,6,255,0,5,7,255,0],"secondary":false},{"width":6,"bonus":105,"chr":"7","pixels":[0,0,255,255,0,6,255,255,0,7,255,255,1,0,255,255,1,1,255,0,1,4,255,255,1,5,255,255,1,7,255,0,1,8,255,0,2,0,255,255,2,1,255,0,2,2,255,255,2,3,255,255,2,5,255,0,2,6,255,0,3,0,255,255,3,1,255,255,3,3,255,0,3,4,255,0,4,1,255,0,4,2,255,0],"secondary":false},{"width":7,"bonus":170,"chr":"8","pixels":[0,1,255,255,0,2,255,255,0,4,255,255,0,5,255,255,0,6,255,255,1,0,255,255,1,2,255,0,1,3,255,255,1,5,255,0,1,6,255,0,1,7,255,255,2,0,255,255,2,1,255,0,2,3,255,255,2,4,255,0,2,7,255,255,2,8,255,0,3,0,255,255,3,1,255,0,3,3,255,255,3,4,255,0,3,7,255,255,3,8,255,0,4,1,255,255,4,2,255,255,4,4,255,255,4,5,255,255,4,6,255,255,4,8,255,0,5,2,255,0,5,3,255,0,5,5,255,0,5,6,255,0,5,7,255,0],"secondary":false},{"width":7,"bonus":130,"chr":"9","pixels":[0,1,255,255,0,2,255,255,1,0,255,255,1,2,255,0,1,3,255,255,2,0,255,255,2,1,255,0,2,4,255,255,3,0,255,255,3,1,255,0,3,4,255,255,3,5,255,0,4,1,255,255,4,2,255,255,4,3,255,255,4,4,255,255,4,5,255,255,4,6,255,255,4,7,255,255,5,2,255,0,5,3,255,0,5,4,255,0,5,5,255,0,5,6,255,0,5,7,255,0,5,8,255,0],"secondary":false},{"width":7,"bonus":130,"chr":"m","pixels":[0,4,255,255,0,5,255,255,0,6,255,255,0,7,255,255,1,3,255,255,1,5,255,0,1,6,255,0,1,7,255,0,1,8,255,0,2,4,255,255,2,5,255,255,2,6,255,255,2,7,255,255,3,3,255,255,3,5,255,0,3,6,255,0,3,7,255,0,3,8,255,0,4,4,255,255,4,5,255,255,4,6,255,255,4,7,255,255,5,5,255,0,5,6,255,0,5,7,255,0,5,8,255,0],"secondary":false},{"width":3,"bonus":85,"chr":"(","pixels":[0,1,255,255,0,2,255,255,0,3,255,255,0,4,255,255,0,5,255,255,0,6,255,255,0,7,255,255,0,8,255,25,1,0,255,255,1,2,255,0,1,3,255,0,1,4,255,0,1,5,255,0,1,6,255,0,1,7,255,0,1,8,255,255,2,1,255,0],"secondary":false},{"width":2,"bonus":70,"chr":")","pixels":[0,1,255,255,0,2,255,255,0,3,255,255,0,4,255,255,0,5,255,255,0,6,255,255,0,7,255,255,1,2,255,0,1,3,255,0,1,4,255,0,1,5,255,0,1,6,255,0,1,7,255,0,1,8,255,0],"secondary":false},{"width":6,"bonus":135,"chr":"h","pixels":[0,0,255,255,0,1,255,255,0,2,255,255,0,3,255,255,0,4,255,255,0,5,255,255,0,6,255,255,0,7,255,255,1,1,255,0,1,2,255,0,1,3,255,255,1,4,255,0,1,5,255,0,1,6,255,0,1,7,255,0,1,8,255,0,2,3,255,255,2,4,255,0,2,5,255,0,3,4,255,255,3,5,255,255,3,6,255,255,3,7,255,255,4,5,255,0,4,6,255,0,4,7,255,0,4,8,255,0],"secondary":false},{"width":5,"bonus":65,"chr":"r","pixels":[0,3,255,255,0,4,255,255,0,5,255,255,0,6,255,255,0,7,255,255,1,4,255,255,1,5,255,0,1,6,255,0,1,7,255,0,1,8,255,0,2,3,255,255,2,5,255,0,3,4,255,0],"secondary":false}],"width":7,"spacewidth":4,"shadow":true,"height":9,"basey":7}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_20993__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_20993__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_20993__("./src/buffs/index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "../node_modules/alt1/dist/ocr/index.js":
/*!**********************************************!*\
  !*** ../node_modules/alt1/dist/ocr/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! alt1/base */ "../node_modules/alt1/dist/base/index.js"));
	else {}
})(globalThis, (__WEBPACK_EXTERNAL_MODULE_alt1_base__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ocr/index.ts":
/*!**************************!*\
  !*** ./src/ocr/index.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_728__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generatefont = exports.readChar = exports.readSmallCapsBackwards = exports.readLine = exports.getChatColor = exports.GetChatColorMono = exports.findReadLine = exports.findChar = exports.decompose3col = exports.decomposeblack = exports.decompose2col = exports.canblend = exports.unblendTrans = exports.unblendKnownBg = exports.unblendBlackBackground = exports.debugFont = exports.debugout = exports.debug = void 0;
const base_1 = __nested_webpack_require_728__(/*! alt1/base */ "alt1/base");
exports.debug = {
    printcharscores: false,
    trackread: false
};
exports.debugout = {};
/**
 * draws the font definition to a buffer and displays it in the dom for debugging purposes
 * @param font
 */
function debugFont(font) {
    var spacing = font.width + 2;
    var buf = new base_1.ImageData(spacing * font.chars.length, font.height + 1);
    for (var a = 0; a < buf.data.length; a += 4) {
        buf.data[a] = buf.data[a + 1] = buf.data[a + 2] = 0;
        buf.data[a + 3] = 255;
    }
    for (var a = 0; a < font.chars.length; a++) {
        var bx = a * spacing;
        var chr = font.chars[a];
        for (var b = 0; b < chr.pixels.length; b += (font.shadow ? 4 : 3)) {
            buf.setPixel(bx + chr.pixels[b], chr.pixels[b + 1], [chr.pixels[b + 2], chr.pixels[b + 2], chr.pixels[b + 2], 255]);
            if (font.shadow) {
                buf.setPixel(bx + chr.pixels[b], chr.pixels[b + 1], [chr.pixels[b + 3], 0, 0, 255]);
            }
        }
    }
    buf.show();
}
exports.debugFont = debugFont;
function unblendBlackBackground(img, r, g, b) {
    var rimg = new base_1.ImageData(img.width, img.height);
    for (var i = 0; i < img.data.length; i += 4) {
        var col = decomposeblack(img.data[i], img.data[i + 1], img.data[i + 2], r, g, b);
        rimg.data[i + 0] = col[0] * 255;
        rimg.data[i + 1] = rimg.data[i + 0];
        rimg.data[i + 2] = rimg.data[i + 0];
        rimg.data[i + 3] = 255;
    }
    return rimg;
}
exports.unblendBlackBackground = unblendBlackBackground;
/**
 * unblends a imagebuffer into match strength with given color
 * the bgimg argument should contain a second image with pixel occluded by the font visible.
 * @param img
 * @param shadow detect black as second color
 * @param bgimg optional second image to
 */
function unblendKnownBg(img, bgimg, shadow, r, g, b) {
    if (bgimg && (img.width != bgimg.width || img.height != bgimg.height)) {
        throw "bgimg size doesn't match";
    }
    var rimg = new base_1.ImageData(img.width, img.height);
    var totalerror = 0;
    for (var i = 0; i < img.data.length; i += 4) {
        var col = decompose2col(img.data[i], img.data[i + 1], img.data[i + 2], r, g, b, bgimg.data[i + 0], bgimg.data[i + 1], bgimg.data[i + 2]);
        if (shadow) {
            if (col[2] > 0.01) {
                console.log("high error component: " + (col[2] * 100).toFixed(1) + "%");
            }
            totalerror += col[2];
            var m = 1 - col[1] - Math.abs(col[2]); //main color+black=100%-bg-error
            rimg.data[i + 0] = m * 255;
            rimg.data[i + 1] = col[0] / m * 255;
            rimg.data[i + 2] = rimg.data[i + 0];
        }
        else {
            rimg.data[i + 0] = col[0] * 255;
            rimg.data[i + 1] = rimg.data[i + 0];
            rimg.data[i + 2] = rimg.data[i + 0];
        }
        rimg.data[i + 3] = 255;
    }
    return rimg;
}
exports.unblendKnownBg = unblendKnownBg;
/**
 * Unblends a font image that is already conpletely isolated to the raw image used ingame. This is the easiest mode for pixel fonts where alpha is 0 or 255, or for extracted font files.
 * @param img
 * @param r
 * @param g
 * @param b
 * @param shadow whether the font has a black shadow
 */
function unblendTrans(img, shadow, r, g, b) {
    var rimg = new base_1.ImageData(img.width, img.height);
    var pxlum = r + g + b;
    for (var i = 0; i < img.data.length; i += 4) {
        if (shadow) {
            var lum = img.data[i + 0] + img.data[i + 1] + img.data[i + 2];
            rimg.data[i + 0] = img.data[i + 3];
            rimg.data[i + 1] = lum / pxlum * 255;
            rimg.data[i + 2] = rimg.data[i + 0];
        }
        else {
            rimg.data[i + 0] = img.data[i + 3];
            rimg.data[i + 1] = rimg.data[i + 0];
            rimg.data[i + 2] = rimg.data[i + 0];
        }
        rimg.data[i + 3] = 255;
    }
    return rimg;
}
exports.unblendTrans = unblendTrans;
/**
 * Determised wether color [rgb]m can be a result of a blend with color [rgb]1 that is p (0-1) of the mix
 * It returns the number that the second color has to lie outside of the possible color ranges
 * @param rm resulting color
 * @param r1 first color of the mix (the other color is unknown)
 * @param p the portion of the [rgb]1 in the mix (0-1)
 */
function canblend(rm, gm, bm, r1, g1, b1, p) {
    var m = Math.min(50, p / (1 - p));
    var r = rm + (rm - r1) * m;
    var g = gm + (gm - g1) * m;
    var b = bm + (bm - b1) * m;
    return Math.max(0, -r, -g, -b, r - 255, g - 255, b - 255);
}
exports.canblend = canblend;
/**
 * decomposes a color in 2 given component colors and returns the amount of each color present
 * also return a third (noise) component which is the the amount leftover orthagonal from the 2 given colors
 */
function decompose2col(rp, gp, bp, r1, g1, b1, r2, g2, b2) {
    //get the normal of the error (cross-product of both colors)
    var r3 = g1 * b2 - g2 * b1;
    var g3 = b1 * r2 - b2 * r1;
    var b3 = r1 * g2 - r2 * g1;
    //normalize to length 255
    var norm = 255 / Math.sqrt(r3 * r3 + g3 * g3 + b3 * b3);
    r3 *= norm;
    g3 *= norm;
    b3 *= norm;
    return decompose3col(rp, gp, bp, r1, g1, b1, r2, g2, b2, r3, g3, b3);
}
exports.decompose2col = decompose2col;
/**
 * decomposes a pixel in a given color component and black and returns what proportion of the second color it contains
 * this is not as formal as decompose 2/3 and only give a "good enough" number
 */
function decomposeblack(rp, gp, bp, r1, g1, b1) {
    var dr = Math.abs(rp - r1);
    var dg = Math.abs(gp - g1);
    var db = Math.abs(bp - b1);
    var maxdif = Math.max(dr, dg, db);
    return [1 - maxdif / 255];
}
exports.decomposeblack = decomposeblack;
/**
 * decomposes a color in 3 given component colors and returns the amount of each color present
 */
function decompose3col(rp, gp, bp, r1, g1, b1, r2, g2, b2, r3, g3, b3) {
    //P=x*C1+y*C2+z*C3
    //assemble as matrix 
    //M*w=p
    //get inverse of M
    //dirty written out version of cramer's rule
    var A = g2 * b3 - b2 * g3;
    var B = g3 * b1 - b3 * g1;
    var C = g1 * b2 - b1 * g2;
    var D = b2 * r3 - r2 * b3;
    var E = b3 * r1 - r3 * b1;
    var F = b1 * r2 - r1 * b2;
    var G = r2 * g3 - g2 * r3;
    var H = r3 * g1 - g3 * r1;
    var I = r1 * g2 - g1 * r2;
    var det = r1 * A + g1 * D + b1 * G;
    //M^-1*p=w
    var x = (A * rp + D * gp + G * bp) / det;
    var y = (B * rp + E * gp + H * bp) / det;
    var z = (C * rp + F * gp + I * bp) / det;
    return [x, y, z];
}
exports.decompose3col = decompose3col;
/**
 * brute force to the exact position of the text
 */
function findChar(buffer, font, col, x, y, w, h) {
    if (x < 0) {
        return null;
    }
    if (y - font.basey < 0) {
        return null;
    }
    if (x + w + font.width > buffer.width) {
        return null;
    }
    if (y + h - font.basey + font.height > buffer.height) {
        return null;
    }
    var best = 1000; //TODO finetune score constants
    var bestchar = null;
    for (var cx = x; cx < x + w; cx++) {
        for (var cy = y; cy < y + h; cy++) {
            var chr = readChar(buffer, font, col, cx, cy, false, false);
            if (chr != null && chr.sizescore < best) {
                best = chr.sizescore;
                bestchar = chr;
            }
        }
    }
    return bestchar;
}
exports.findChar = findChar;
/**
 * reads text with unknown exact coord or color. The given coord should be inside the text
 * color selection not implemented yet
 */
function findReadLine(buffer, font, cols, x, y, w = -1, h = -1) {
    if (w == -1) {
        w = font.width + font.spacewidth;
        x -= Math.ceil(w / 2);
    }
    if (h == -1) {
        h = 7;
        y -= 1;
    }
    var chr = null;
    if (cols.length > 1) {
        //TODO use getChatColor() instead for non-mono?
        var sorted = GetChatColorMono(buffer, new base_1.Rect(x, y - font.basey, w, h), cols);
        //loop until we have a match (max 2 cols)
        for (var a = 0; a < 2 && a < sorted.length && chr == null; a++) {
            chr = findChar(buffer, font, sorted[a].col, x, y, w, h);
        }
    }
    else {
        chr = findChar(buffer, font, cols[0], x, y, w, h);
    }
    if (chr == null) {
        return { debugArea: { x, y, w, h }, text: "", fragments: [] };
    }
    return readLine(buffer, font, cols, chr.x, chr.y, true, true);
}
exports.findReadLine = findReadLine;
function GetChatColorMono(buf, rect, colors) {
    var colormap = colors.map(c => ({ col: c, score: 0 }));
    if (rect.x < 0 || rect.y < 0 || rect.x + rect.width > buf.width || rect.y + rect.height > buf.height) {
        return colormap;
    }
    var data = buf.data;
    var maxd = 50;
    for (var colobj of colormap) {
        var score = 0;
        var col = colobj.col;
        for (var y = rect.y; y < rect.y + rect.height; y++) {
            for (var x = rect.x; x < rect.x + rect.width; x++) {
                var i = x * 4 + y * 4 * buf.width;
                var d = Math.abs(data[i] - col[0]) + Math.abs(data[i + 1] - col[1]) + Math.abs(data[i + 2] - col[2]);
                if (d < maxd) {
                    score += maxd - d;
                }
            }
        }
        colobj.score = score;
    }
    return colormap.sort((a, b) => b.score - a.score);
}
exports.GetChatColorMono = GetChatColorMono;
function unblend(r, g, b, R, G, B) {
    var m = Math.sqrt(r * r + g * g + b * b);
    var n = Math.sqrt(R * R + G * G + B * B);
    var x = (r * R + g * G + b * B) / n;
    var y = Math.sqrt(Math.max(0, m * m - x * x));
    var r1 = Math.max(0, (63.75 - y) * 4);
    var r2 = x / n * 255;
    if (r2 > 255) //brighter than refcol
     {
        r1 = Math.max(0, r1 - r2 + 255);
        r2 = 255;
    }
    return [r1, r2];
}
function getChatColor(buf, rect, colors) {
    var bestscore = -1.0;
    var best = null;
    var b2 = 0.0;
    var data = buf.data;
    for (let col of colors) {
        var score = 0.0;
        for (var y = rect.y; y < rect.y + rect.height; y++) {
            for (var x = rect.x; x < rect.x + rect.width; x++) {
                if (x < 0 || x + 1 >= buf.width) {
                    continue;
                }
                if (y < 0 || y + 1 >= buf.width) {
                    continue;
                }
                let i1 = buf.pixelOffset(x, y);
                let i2 = buf.pixelOffset(x + 1, y + 1);
                var pixel1 = unblend(data[i1 + 0], data[i1 + 1], data[i1 + 2], col[0], col[1], col[2]);
                var pixel2 = unblend(data[i2 + 0], data[i2 + 1], data[i2 + 2], col[0], col[1], col[2]);
                //TODO this is from c# can simplify a bit
                var s = (pixel1[0] / 255 * pixel1[1] / 255) * (pixel2[0] / 255 * (255.0 - pixel2[1]) / 255);
                score += s;
            }
        }
        if (score > bestscore) {
            b2 = bestscore;
            bestscore = score;
            best = col;
        }
        else if (score > b2) {
            b2 = score;
        }
    }
    //Console.WriteLine("color: " + bestcol + " - " + (bestscore - b2));
    //bestscore /= rect.width * rect.height;
    return best;
}
exports.getChatColor = getChatColor;
/**
 * reads a line of text with exactly known position and color. y should be the y coord of the text base line, x should be the first pixel of a new character
 */
function readLine(buffer, font, colors, x, y, forward, backward = false) {
    if (typeof colors[0] != "number" && colors.length == 1) {
        colors = colors[0];
    }
    var multicol = typeof colors[0] != "number";
    var allcolors = multicol ? colors : [colors];
    var detectcolor = function (sx, sy, backward) {
        var w = Math.floor(font.width * 1.5);
        if (backward) {
            sx -= w;
        }
        sy -= font.basey;
        return getChatColor(buffer, { x: sx, y: sy, width: w, height: font.height }, allcolors);
    };
    var fragments = [];
    var x1 = x;
    var x2 = x;
    var maxspaces = (typeof font.maxspaces == "number" ? font.maxspaces : 1);
    let fragtext = "";
    let fraghadprimary = false;
    var lastcol = null;
    let addfrag = (forward) => {
        if (!fragtext) {
            return;
        }
        let frag = {
            text: fragtext,
            color: lastcol,
            index: 0,
            xstart: x + (forward ? fragstartdx : fragenddx),
            xend: x + (forward ? fragenddx : fragstartdx)
        };
        if (forward) {
            fragments.push(frag);
        }
        else {
            fragments.unshift(frag);
        }
        fragtext = "";
        fragstartdx = dx;
        fraghadprimary = false;
    };
    for (var dirforward of [true, false]) {
        //init vars
        if (dirforward && !forward) {
            continue;
        }
        if (!dirforward && !backward) {
            continue;
        }
        var dx = 0;
        var fragstartdx = dx;
        var fragenddx = dx;
        var triedspaces = 0;
        var triedrecol = false;
        var col = multicol ? null : colors;
        while (true) {
            col = col || detectcolor(x + dx, y, !dirforward);
            var chr = (col ? readChar(buffer, font, col, x + dx, y, !dirforward, true) : null);
            if (col == null || chr == null) {
                if (triedspaces < maxspaces) {
                    dx += (dirforward ? 1 : -1) * font.spacewidth;
                    triedspaces++;
                    continue;
                }
                if (multicol && !triedrecol && fraghadprimary) {
                    dx -= (dirforward ? 1 : -1) * triedspaces * font.spacewidth;
                    triedspaces = 0;
                    col = null;
                    triedrecol = true;
                    continue;
                }
                if (dirforward) {
                    x2 = x + dx - font.spacewidth;
                }
                else {
                    x1 = x + dx + font.spacewidth;
                }
                break;
            }
            else {
                if (lastcol && (col[0] != lastcol[0] || col[1] != lastcol[1] || col[2] != lastcol[2])) {
                    addfrag(dirforward);
                }
                var spaces = "";
                for (var a = 0; a < triedspaces; a++) {
                    spaces += " ";
                }
                if (dirforward) {
                    fragtext += spaces + chr.chr;
                }
                else {
                    fragtext = chr.chr + spaces + fragtext;
                }
                if (!chr.basechar.secondary) {
                    fraghadprimary = true;
                }
                triedspaces = 0;
                triedrecol = false;
                dx += (dirforward ? 1 : -1) * chr.basechar.width;
                fragenddx = dx;
                lastcol = col;
            }
        }
        if (lastcol && fraghadprimary) {
            addfrag(dirforward);
        }
    }
    fragments.forEach((f, i) => f.index = i);
    return {
        debugArea: { x: x1, y: y - 9, w: x2 - x1, h: 10 },
        text: fragments.map(f => f.text).join(""),
        fragments
    };
}
exports.readLine = readLine;
/**
 * Reads a line of text that uses a smallcaps font, these fonts can have duplicate chars that only have a different amount of
 * empty space after the char before the next char starts.
 * The coordinates should be near the end of the string, or a rectangle with high 1 containing all points where the string can end.
 */
function readSmallCapsBackwards(buffer, font, cols, x, y, w = -1, h = -1) {
    if (w == -1) {
        w = font.width + font.spacewidth;
        x -= Math.ceil(w / 2);
    }
    if (h == -1) {
        h = 7;
        y -= 1;
    }
    var matchedchar = null;
    var sorted = (cols.length == 1 ? [{ col: cols[0], score: 1 }] : GetChatColorMono(buffer, new base_1.Rect(x, y - font.basey, w, h), cols));
    //loop until we have a match (max 2 cols)
    for (var a = 0; a < 2 && a < sorted.length && matchedchar == null; a++) {
        for (var cx = x + w - 1; cx >= x; cx--) {
            var best = 1000; //TODO finetune score constants
            var bestchar = null;
            for (var cy = y; cy < y + h; cy++) {
                var chr = readChar(buffer, font, sorted[a].col, cx, cy, true, false);
                if (chr != null && chr.sizescore < best) {
                    best = chr.sizescore;
                    bestchar = chr;
                }
            }
            if (bestchar) {
                matchedchar = bestchar;
                break;
            }
        }
    }
    if (matchedchar == null) {
        return { text: "", debugArea: { x, y, w, h } };
    }
    return readLine(buffer, font, cols, matchedchar.x, matchedchar.y, false, true);
}
exports.readSmallCapsBackwards = readSmallCapsBackwards;
/**
 * Reads a single character at the exact given location
 * @param x exact x location of the start of the character domain (includes part of the spacing between characters)
 * @param y exact y location of the baseline pixel of the character
 * @param backwards read in backwards direction, the x location should be the first pixel after the character domain in that case
 */
function readChar(buffer, font, col, x, y, backwards, allowSecondary) {
    y -= font.basey;
    var shiftx = 0;
    var shifty = font.basey;
    var shadow = font.shadow;
    var debugobj = null;
    var debugimg = null;
    if (exports.debug.trackread) {
        var name = x + ";" + y + " " + JSON.stringify(col);
        if (!exports.debugout[name]) {
            exports.debugout[name] = [];
        }
        debugobj = exports.debugout[name];
    }
    //===== make sure the full domain is inside the bitmap/buffer ======
    if (y < 0 || y + font.height >= buffer.height) {
        return null;
    }
    if (!backwards) {
        if (x < 0 || x + font.width > buffer.width) {
            return null;
        }
    }
    else {
        if (x - font.width < 0 || x > buffer.width) {
            return null;
        }
    }
    //====== start reading the char ======
    var scores = [];
    for (var chr = 0; chr < font.chars.length; chr++) {
        var chrobj = font.chars[chr];
        if (chrobj.secondary && !allowSecondary) {
            continue;
        }
        scores[chr] = { score: 0, sizescore: 0, chr: chrobj };
        var chrx = (backwards ? x - chrobj.width : x);
        if (exports.debug.trackread) {
            debugimg = new base_1.ImageData(font.width, font.height);
        }
        for (var a = 0; a < chrobj.pixels.length;) {
            var i = (chrx + chrobj.pixels[a]) * 4 + (y + chrobj.pixels[a + 1]) * buffer.width * 4;
            var penalty = 0;
            if (!shadow) {
                penalty = canblend(buffer.data[i], buffer.data[i + 1], buffer.data[i + 2], col[0], col[1], col[2], chrobj.pixels[a + 2] / 255);
                a += 3;
            }
            else {
                var lum = chrobj.pixels[a + 3] / 255;
                penalty = canblend(buffer.data[i], buffer.data[i + 1], buffer.data[i + 2], col[0] * lum, col[1] * lum, col[2] * lum, chrobj.pixels[a + 2] / 255);
                a += 4;
            }
            scores[chr].score += Math.max(0, penalty);
            //TODO add compiler flag to this to remove it for performance
            if (debugimg) {
                debugimg.setPixel(chrobj.pixels[a], chrobj.pixels[a + 1], [penalty, penalty, penalty, 255]);
            }
        }
        scores[chr].sizescore = scores[chr].score - chrobj.bonus;
        if (debugobj) {
            debugobj.push({ chr: chrobj.chr, score: scores[chr].sizescore, rawscore: scores[chr].score, img: debugimg });
        }
    }
    scores.sort((a, b) => a.sizescore - b.sizescore);
    if (exports.debug.printcharscores) {
        scores.slice(0, 5).forEach(q => console.log(q.chr.chr, q.score.toFixed(3), q.sizescore.toFixed(3)));
    }
    var winchr = scores[0];
    if (!winchr || winchr.score > 400) {
        return null;
    }
    return { chr: winchr.chr.chr, basechar: winchr.chr, x: x + shiftx, y: y + shifty, score: winchr.score, sizescore: winchr.sizescore };
}
exports.readChar = readChar;
/**
 * Generates a font json description to use in reader functions
 * @param unblended A source image with all characters lined up. The image should be unblended into components using the unblend functions
 * The lowest pixel line of this image is used to mark the location and size of the charecters if the red component is 255 it means there is a character on that pixel column
 * @param chars A string containing all the characters of the image in the same order
 * @param seconds A string with characters that are considered unlikely and should only be detected if no other character is possible.
 * For example the period (.) character matches positive inside many other characters and should be marked as secondary
 * @param bonusses An object that contains bonus scores for certain difficult characters to make the more likely to be red.
 * @param basey The y position of the baseline pixel of the font
 * @param spacewidth the number of pixels a space takes
 * @param treshold minimal color match proportion (0-1) before a pixel is used for the font
 * @param shadow whether this font also uses the black shadow some fonts have. The "unblended" image should be unblended correspondingly
 * @returns a javascript object describing the font which is used as input for the different read functions
 */
function generatefont(unblended, chars, seconds, bonusses, basey, spacewidth, treshold, shadow) {
    //settings vars
    treshold *= 255;
    //initial vars
    var miny = unblended.height - 1;
    var maxy = 0;
    var font = { chars: [], width: 0, spacewidth: spacewidth, shadow: shadow, height: 0, basey: 0 };
    var ds = false;
    var chardata = [];
    //index all chars
    for (var dx = 0; dx < unblended.width; dx++) {
        var i = 4 * dx + 4 * unblended.width * (unblended.height - 1);
        if (unblended.data[i] == 255 && unblended.data[i + 3] == 255) {
            if (ds === false) {
                ds = dx;
            }
        }
        else {
            if (ds !== false) {
                //char found, start detection
                var de = dx;
                var char = chars[chardata.length];
                var chr = {
                    ds: ds,
                    de: de,
                    width: de - ds,
                    chr: char,
                    bonus: (bonusses && bonusses[char]) || 0,
                    secondary: seconds.indexOf(chars[chardata.length]) != -1,
                    pixels: []
                };
                chardata.push(chr);
                font.width = Math.max(font.width, chr.width);
                for (x = 0; x < de - ds; x++) {
                    for (y = 0; y < unblended.height - 1; y++) {
                        var i = (x + ds) * 4 + y * unblended.width * 4;
                        if (unblended.data[i] >= treshold) {
                            miny = Math.min(miny, y);
                            maxy = Math.max(maxy, y);
                        }
                    }
                }
                ds = false;
            }
        }
    }
    font.height = maxy + 1 - miny;
    font.basey = basey - miny;
    //detect all pixels
    for (var a in chardata) {
        var chr = chardata[a];
        for (var x = 0; x < chr.width; x++) {
            for (var y = 0; y < maxy + 1 - miny; y++) {
                var i = (x + chr.ds) * 4 + (y + miny) * unblended.width * 4;
                if (unblended.data[i] >= treshold) {
                    chr.pixels.push(x, y);
                    chr.pixels.push(unblended.data[i]);
                    if (shadow) {
                        chr.pixels.push(unblended.data[i + 1]);
                    }
                    chr.bonus += 5;
                }
            }
        }
        //prevent js from doing the thing with unnecessary output precision
        chr.bonus = +chr.bonus.toFixed(3);
        font.chars.push({ width: chr.width, bonus: chr.bonus, chr: chr.chr, pixels: chr.pixels, secondary: chr.secondary });
    }
    return font;
}
exports.generatefont = generatefont;


/***/ }),

/***/ "alt1/base":
/*!**************************************************************************************************!*\
  !*** external {"root":"A1lib","commonjs2":"alt1/base","commonjs":"alt1/base","amd":"alt1/base"} ***!
  \**************************************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_alt1_base__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_26177__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_26177__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_26177__("./src/ocr/index.ts");
/******/ 	
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   saveSettings: () => (/* binding */ saveSettings),
/* harmony export */   setLoc: () => (/* binding */ setLoc),
/* harmony export */   start: () => (/* binding */ start)
/* harmony export */ });
/* harmony import */ var alt1__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! alt1 */ "../node_modules/alt1/dist/base/index.js");
/* harmony import */ var alt1__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(alt1__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var alt1_buffs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! alt1/buffs */ "../node_modules/alt1/dist/buffs/index.js");
/* harmony import */ var alt1_buffs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(alt1_buffs__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _index_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.html */ "./index.html");
/* harmony import */ var _appconfig_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./appconfig.json */ "./appconfig.json");
/* harmony import */ var _icon_png__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icon.png */ "./icon.png");
/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.css */ "./index.css");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
// alt1 base libs, provides all the commonly used methods for image matching and capture
// also gives your editor info about the window.alt1 api


// tell webpack that this file relies index.html, appconfig.json and icon.png, this makes webpack
// add these files to the output directory
// this works because in /webpack.config.js we told webpack to treat all html, json and imageimports
// as assets




var output = document.getElementById("output");
var settings = document.getElementById("settings");
var track_fod = document.getElementById("fod");
var track_strike = document.getElementById("strike");
var track_volley = document.getElementById("volley");
var drawInterface = null;
var necrosis = alt1__WEBPACK_IMPORTED_MODULE_4__.webpackImages({
    6: __webpack_require__(/*! ./necro6.data.png */ "./necro6.data.png"),
    8: __webpack_require__(/*! ./necro8.data.png */ "./necro8.data.png"),
    10: __webpack_require__(/*! ./necro10.data.png */ "./necro10.data.png"),
    12: __webpack_require__(/*! ./necro12.data.png */ "./necro12.data.png"),
    fod: __webpack_require__(/*! ./fod.data.png */ "./fod.data.png"),
    soul1: __webpack_require__(/*! ./soul1.data.png */ "./soul1.data.png"),
    soul2: __webpack_require__(/*! ./soul2.data.png */ "./soul2.data.png"),
    soul3: __webpack_require__(/*! ./soul3.data.png */ "./soul3.data.png"),
    soul4: __webpack_require__(/*! ./soul4.data.png */ "./soul4.data.png"),
    soul5: __webpack_require__(/*! ./soul5.data.png */ "./soul5.data.png"),
    volley: __webpack_require__(/*! ./volley.data.png */ "./volley.data.png"),
    strike: __webpack_require__(/*! ./strike.data.png */ "./strike.data.png"),
});
function monitorNecrosis(img) {
    var loc = getSetting("loc");
    var is6 = img.findSubimage(necrosis[6]).length;
    var is8 = img.findSubimage(necrosis[8]).length;
    var is10 = img.findSubimage(necrosis[10]).length;
    var is12 = img.findSubimage(necrosis[12]).length;
    var soul1 = img.findSubimage(necrosis.soul1).length;
    var soul2 = img.findSubimage(necrosis.soul2).length;
    var soul3 = img.findSubimage(necrosis.soul3).length;
    var soul4 = img.findSubimage(necrosis.soul4).length;
    var soul5 = img.findSubimage(necrosis.soul5).length;
    var fod = alt1__WEBPACK_IMPORTED_MODULE_4__.encodeImageString(necrosis.fod);
    var strike = alt1__WEBPACK_IMPORTED_MODULE_4__.encodeImageString(necrosis.strike);
    var volley = alt1__WEBPACK_IMPORTED_MODULE_4__.encodeImageString(necrosis.volley);
    if (getSetting("track_fod")) {
        if (is6 || is8 || is10 || is12) {
            alt1.overLayImage(loc.x + 6, loc.y + 6, fod, 60, 300);
            alt1.overLayRect(alt1__WEBPACK_IMPORTED_MODULE_4__.mixColor(255, 255, 255), loc.x + 3, loc.y + 3, 63, 63, 300, 3);
        }
        if (is12) {
            alt1.overLayText("x2", alt1__WEBPACK_IMPORTED_MODULE_4__.mixColor(0, 255, 0), 20, loc.x + 3, loc.y + 3, 300);
        }
    }
    if (getSetting("track_strike")) {
        if (soul1 || soul2 || soul3 || soul4 || soul5) {
            alt1.overLayImage(loc.x + 71, loc.y + 6, strike, 60, 300);
            alt1.overLayRect(alt1__WEBPACK_IMPORTED_MODULE_4__.mixColor(255, 255, 255), loc.x + 68, loc.y + 3, 63, 63, 300, 3);
        }
        if (soul2)
            alt1.overLayText("x2", alt1__WEBPACK_IMPORTED_MODULE_4__.mixColor(0, 255, 0), 20, loc.x + 68, loc.y + 3, 300);
        if (soul3)
            alt1.overLayText("x3", alt1__WEBPACK_IMPORTED_MODULE_4__.mixColor(0, 255, 0), 20, loc.x + 68, loc.y + 3, 300);
        if (soul4)
            alt1.overLayText("x4", alt1__WEBPACK_IMPORTED_MODULE_4__.mixColor(0, 255, 0), 20, loc.x + 68, loc.y + 3, 300);
        if (soul5)
            alt1.overLayText("x5", alt1__WEBPACK_IMPORTED_MODULE_4__.mixColor(0, 255, 0), 20, loc.x + 68, loc.y + 3, 300);
    }
    if (getSetting("track_volley")) {
        if (soul3 || soul4 || soul5) {
            alt1.overLayImage(loc.x + 136, loc.y + 6, volley, 60, 300);
            alt1.overLayRect(alt1__WEBPACK_IMPORTED_MODULE_4__.mixColor(255, 255, 255), loc.x + 133, loc.y + 3, 63, 63, 300, 3);
        }
    }
}
window.onload = function () {
    //check if we are running inside alt1 by checking if the alt1 global exists
    if (window.alt1) {
        //tell alt1 about the app
        //this makes alt1 show the add app button when running inside the embedded browser
        //also updates app settings if they are changed
        alt1.identifyAppUrl("./appconfig.json");
        var buffs_1 = new (alt1_buffs__WEBPACK_IMPORTED_MODULE_5___default())();
        output.innerHTML = "Searching for buffs...";
        settings.style.display = "none";
        var findBuffs_1 = setInterval(function () {
            if (buffs_1.find()) {
                settings.style.display = "block";
                output.innerHTML = "";
                clearInterval(findBuffs_1);
                start();
            }
        });
    }
    else {
        var addappurl = "alt1://addapp/".concat(new URL("./appconfig.json", document.location.href).href);
        output.insertAdjacentHTML("beforeend", "\n\t\tAlt1 not detected, click <a href='".concat(addappurl, "'>here</a> to add this app to Alt1\n\t"));
    }
};
function start() {
    try {
        if (!localStorage.necroJobGauge) {
            initializeSettings();
        }
        track_fod.checked = getSetting("track_fod");
        track_volley.checked = getSetting("track_volley");
        track_strike.checked = getSetting("track_strike");
        var buffsLoc_1 = getSetting("buffsLoc");
        setInterval(function () {
            return __awaiter(this, void 0, void 0, function () {
                var img;
                return __generator(this, function (_a) {
                    img = alt1__WEBPACK_IMPORTED_MODULE_4__.captureHold(buffsLoc_1.x, buffsLoc_1.y, buffsLoc_1.width, buffsLoc_1.height);
                    monitorNecrosis(img);
                    return [2 /*return*/];
                });
            });
        }, 200);
    }
    catch (error) {
        if (alt1.permissionPixel)
            window.location.reload();
    }
}
function setLoc() {
    alt1__WEBPACK_IMPORTED_MODULE_4__.once("alt1pressed", onalt1);
    alt1.setTooltip("Move mouse to where you want to relocate the interface.  Then press Alt+1");
    output.innerHTML = "Move mouse to where you want to relocate the interface.  Then press Alt+1";
    drawInterface = setInterval(function () {
        alt1.overLayRect(alt1__WEBPACK_IMPORTED_MODULE_4__.mixColor(0, 255, 0), alt1__WEBPACK_IMPORTED_MODULE_4__.getMousePosition().x - 98, alt1__WEBPACK_IMPORTED_MODULE_4__.getMousePosition().y - 35, 195, 70, 200, 1);
    }, 200);
}
function onalt1(e) {
    saveSettings("loc", { x: e.x - 98, y: e.y - 35 });
    clearInterval(drawInterface);
    alt1.clearTooltip();
    output.innerHTML = "";
}
function saveSettings(setting, value) {
    if (!localStorage.getItem("necroJobGauge")) {
        localStorage.setItem("necroJobGauge", JSON.stringify({}));
    }
    var save_data = JSON.parse(localStorage.getItem("necroJobGauge"));
    save_data[setting] = value;
    localStorage.setItem("necroJobGauge", JSON.stringify(save_data));
}
function getSetting(setting) {
    if (!localStorage.necroJobGauge) {
        initializeSettings();
    }
    return JSON.parse(localStorage.getItem("necroJobGauge"))[setting];
}
function initializeSettings() {
    localStorage.setItem("necroJobGauge", JSON.stringify({
        loc: {
            x: (Math.round(alt1.rsWidth / 2)),
            y: (Math.round(alt1.rsHeight / 2))
        },
        track_fod: false,
        track_strike: false,
        track_volley: false,
        buffsLoc: getBuffsLoc()
    }));
}
function getBuffsLoc() {
    var buffs = new (alt1_buffs__WEBPACK_IMPORTED_MODULE_5___default())();
    if (buffs.find()) {
        return buffs.getCaptRect();
    }
    else {
        getBuffsLoc();
    }
}

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});